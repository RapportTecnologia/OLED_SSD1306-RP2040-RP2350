<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RP2040 OLED SSD1306: mutex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RP2040 OLED SSD1306
   </div>
   <div id="projectbrief">Driver/Exemplos para display OLED SSD1306 no RP2040</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Gerado por Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Localizar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__mutex.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Carregando...</div>
<div class="SRStatus" id="Searching">Procurando...</div>
<div class="SRStatus" id="NoMatches">Nenhuma entrada encontrada</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Componentes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Definições de tipos</a> &#124;
<a href="#func-members">Funções</a>  </div>
  <div class="headertitle"><div class="title">mutex<div class="ingroups"><a class="el" href="group__pico__sync.html">pico_sync</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Mutex API for non IRQ mutual exclusion between cores.  
<a href="#details">Mais...</a></p>
<div class="dynheader">
Diagrama de colaboração para mutex:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__mutex.svg" width="210" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Componentes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutex.html">mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">regular (non recursive) mutex instance  <a href="structmutex.html#details">Mais...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive mutex instance  <a href="structrecursive__mutex__t.html#details">Mais...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa1b5d9dea897013fc5e40bf102045592" id="r_gaa1b5d9dea897013fc5e40bf102045592"><td class="memItemLeft" align="right" valign="top">#<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gaa1b5d9dea897013fc5e40bf102045592">auto_init_mutex</a>(name)&#160;&#160;&#160;<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">static</a> <a class="el" href="group__pico__bootrom.html#gaa0d8e5afb2db73425ff3ce85ee0bdbdc">__attribute__</a>((<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">section</a>(&quot;.mutex_array&quot;))) <a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> name</td></tr>
<tr class="memdesc:gaa1b5d9dea897013fc5e40bf102045592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for static definition of mutexes.  <br /></td></tr>
<tr class="separator:gaa1b5d9dea897013fc5e40bf102045592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c019cd595a52ee87e06bdf20e427660" id="r_ga3c019cd595a52ee87e06bdf20e427660"><td class="memItemLeft" align="right" valign="top">#<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga3c019cd595a52ee87e06bdf20e427660">auto_init_recursive_mutex</a>(name)&#160;&#160;&#160;<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">static</a> <a class="el" href="group__pico__bootrom.html#gaa0d8e5afb2db73425ff3ce85ee0bdbdc">__attribute__</a>((<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">section</a>(&quot;.mutex_array&quot;))) <a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> name = { .core = { .spin_lock = (<a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a96af910e1f1911aa6eb0b9f84410a151">spin_lock_t</a> *)1 /* <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">marker</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">for</a> <a class="el" href="group__pico__runtime.html#gad27ee86dcd85855022a424f61b839d04">runtime_init</a> */ }, .owner = 0, .enter_count = 0 }</td></tr>
<tr class="memdesc:ga3c019cd595a52ee87e06bdf20e427660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for static definition of recursive mutexes.  <br /></td></tr>
<tr class="separator:ga3c019cd595a52ee87e06bdf20e427660"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Definições de tipos</h2></td></tr>
<tr class="memitem:gac32ff6793a910bc7b48c8b0bb3c47ea7" id="r_gac32ff6793a910bc7b48c8b0bb3c47ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">typedef</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">struct</a> <a class="el" href="structmutex.html">mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a></td></tr>
<tr class="memdesc:gac32ff6793a910bc7b48c8b0bb3c47ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">regular (non recursive) mutex instance  <br /></td></tr>
<tr class="separator:gac32ff6793a910bc7b48c8b0bb3c47ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Funções</h2></td></tr>
<tr class="memitem:ga69e2f75f0a38378b20c0f2bf9cc7bbe3" id="r_ga69e2f75f0a38378b20c0f2bf9cc7bbe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">mutex_enter_block_until</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="common_2pico__base__headers_2include_2pico_2types_8h.html#afd2047ec52f48f0e893289f03ec5bf5e">absolute_time_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">until</a>)</td></tr>
<tr class="memdesc:ga69e2f75f0a38378b20c0f2bf9cc7bbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for mutex until a specific time.  <br /></td></tr>
<tr class="separator:ga69e2f75f0a38378b20c0f2bf9cc7bbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b1c7af0545f478c80b51513d8f6993" id="r_ga65b1c7af0545f478c80b51513d8f6993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga65b1c7af0545f478c80b51513d8f6993">mutex_enter_blocking</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>)</td></tr>
<tr class="memdesc:ga65b1c7af0545f478c80b51513d8f6993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of a mutex.  <br /></td></tr>
<tr class="separator:ga65b1c7af0545f478c80b51513d8f6993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c6e468289a81a49b4bde50a6280f83" id="r_ga32c6e468289a81a49b4bde50a6280f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga32c6e468289a81a49b4bde50a6280f83">mutex_enter_timeout_ms</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">timeout_ms</a>)</td></tr>
<tr class="memdesc:ga32c6e468289a81a49b4bde50a6280f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for mutex with timeout.  <br /></td></tr>
<tr class="separator:ga32c6e468289a81a49b4bde50a6280f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553f33e9692a19f8ad956a8b770858e0" id="r_ga553f33e9692a19f8ad956a8b770858e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga553f33e9692a19f8ad956a8b770858e0">mutex_enter_timeout_us</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">timeout_us</a>)</td></tr>
<tr class="memdesc:ga553f33e9692a19f8ad956a8b770858e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for mutex with timeout.  <br /></td></tr>
<tr class="separator:ga553f33e9692a19f8ad956a8b770858e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf528c8fbb5f4532758859d18e24e1673" id="r_gaf528c8fbb5f4532758859d18e24e1673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gaf528c8fbb5f4532758859d18e24e1673">mutex_exit</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>)</td></tr>
<tr class="memdesc:gaf528c8fbb5f4532758859d18e24e1673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of a mutex.  <br /></td></tr>
<tr class="separator:gaf528c8fbb5f4532758859d18e24e1673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe21d7ce624db2df7afe86c4bba400a2" id="r_gabe21d7ce624db2df7afe86c4bba400a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gabe21d7ce624db2df7afe86c4bba400a2">mutex_init</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>)</td></tr>
<tr class="memdesc:gabe21d7ce624db2df7afe86c4bba400a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a mutex structure.  <br /></td></tr>
<tr class="separator:gabe21d7ce624db2df7afe86c4bba400a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa116de2f28fd7df8fb78b210e07b1ed4" id="r_gaa116de2f28fd7df8fb78b210e07b1ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gaa116de2f28fd7df8fb78b210e07b1ed4">mutex_try_enter</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">owner_out</a>)</td></tr>
<tr class="memdesc:gaa116de2f28fd7df8fb78b210e07b1ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to take ownership of a mutex.  <br /></td></tr>
<tr class="separator:gaa116de2f28fd7df8fb78b210e07b1ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91088e6bd3929dcf86ed12cd92ee2cd8" id="r_ga91088e6bd3929dcf86ed12cd92ee2cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga91088e6bd3929dcf86ed12cd92ee2cd8">mutex_try_enter_block_until</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="common_2pico__base__headers_2include_2pico_2types_8h.html#afd2047ec52f48f0e893289f03ec5bf5e">absolute_time_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">until</a>)</td></tr>
<tr class="memdesc:ga91088e6bd3929dcf86ed12cd92ee2cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to take ownership of a mutex until the specified time.  <br /></td></tr>
<tr class="separator:ga91088e6bd3929dcf86ed12cd92ee2cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce3ca26cbce71a3e29396264e00e253" id="r_ga6ce3ca26cbce71a3e29396264e00e253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga6ce3ca26cbce71a3e29396264e00e253">recursive_mutex_enter_block_until</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="common_2pico__base__headers_2include_2pico_2types_8h.html#afd2047ec52f48f0e893289f03ec5bf5e">absolute_time_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">until</a>)</td></tr>
<tr class="memdesc:ga6ce3ca26cbce71a3e29396264e00e253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for mutex until a specific time.  <br /></td></tr>
<tr class="separator:ga6ce3ca26cbce71a3e29396264e00e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11f3d954d96cfdc77025735d35983e1" id="r_gad11f3d954d96cfdc77025735d35983e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gad11f3d954d96cfdc77025735d35983e1">recursive_mutex_enter_blocking</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>)</td></tr>
<tr class="memdesc:gad11f3d954d96cfdc77025735d35983e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of a recursive mutex.  <br /></td></tr>
<tr class="separator:gad11f3d954d96cfdc77025735d35983e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54a0bdb7967571caecb62869bd4194d" id="r_gad54a0bdb7967571caecb62869bd4194d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gad54a0bdb7967571caecb62869bd4194d">recursive_mutex_enter_timeout_ms</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">timeout_ms</a>)</td></tr>
<tr class="memdesc:gad54a0bdb7967571caecb62869bd4194d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for recursive mutex with timeout.  <br /></td></tr>
<tr class="separator:gad54a0bdb7967571caecb62869bd4194d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb630a7c13ed3adc567e62c8c737401" id="r_gaeeb630a7c13ed3adc567e62c8c737401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gaeeb630a7c13ed3adc567e62c8c737401">recursive_mutex_enter_timeout_us</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">timeout_us</a>)</td></tr>
<tr class="memdesc:gaeeb630a7c13ed3adc567e62c8c737401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for recursive mutex with timeout.  <br /></td></tr>
<tr class="separator:gaeeb630a7c13ed3adc567e62c8c737401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f75321a04ba731f5875353fbaebc345" id="r_ga2f75321a04ba731f5875353fbaebc345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga2f75321a04ba731f5875353fbaebc345">recursive_mutex_exit</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>)</td></tr>
<tr class="memdesc:ga2f75321a04ba731f5875353fbaebc345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of a recursive mutex.  <br /></td></tr>
<tr class="separator:ga2f75321a04ba731f5875353fbaebc345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d1f9d58564a1799e293451edc2d28e" id="r_ga30d1f9d58564a1799e293451edc2d28e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga30d1f9d58564a1799e293451edc2d28e">recursive_mutex_init</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>)</td></tr>
<tr class="memdesc:ga30d1f9d58564a1799e293451edc2d28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a recursive mutex structure.  <br /></td></tr>
<tr class="separator:ga30d1f9d58564a1799e293451edc2d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae431bbb90e45cf9ae47130a5635aa2b0" id="r_gae431bbb90e45cf9ae47130a5635aa2b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gae431bbb90e45cf9ae47130a5635aa2b0">recursive_mutex_try_enter</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">mtx</a>, <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> *<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">owner_out</a>)</td></tr>
<tr class="memdesc:gae431bbb90e45cf9ae47130a5635aa2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to take ownership of a recursive mutex.  <br /></td></tr>
<tr class="separator:gae431bbb90e45cf9ae47130a5635aa2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrição detalhada</h2>
<p>Mutex API for non IRQ mutual exclusion between cores. </p>
<p>Mutexes are application level locks usually used protecting data structures that might be used by multiple threads of execution. Unlike critical sections, the mutex protected code is not necessarily required/expected to complete quickly, as no other system wide locks are held on account of an acquired mutex.</p>
<p>When acquired, the mutex has an owner (see <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>) which with the plain SDK is just the acquiring core, but in an RTOS it could be a task, or an IRQ handler context.</p>
<p>Two variants of mutex are provided; <a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> (and associated mutex_ functions) is a regular mutex that cannot be acquired recursively by the same owner (a deadlock will occur if you try). <a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> (and associated recursive_mutex_ functions) is a recursive mutex that can be recursively obtained by the same caller, at the expense of some more overhead when acquiring and releasing.</p>
<p>It is generally a bad idea to call blocking mutex_ or recursive_mutex_ functions from within an IRQ handler. It is valid to call <a class="el" href="group__mutex.html#gaa116de2f28fd7df8fb78b210e07b1ed4">mutex_try_enter</a> or <a class="el" href="group__mutex.html#gae431bbb90e45cf9ae47130a5635aa2b0">recursive_mutex_try_enter</a> from within an IRQ handler, if the operation that would be conducted under lock can be skipped if the mutex is locked (at least by the same owner).</p>
<p>NOTE: For backwards compatibility with version 1.2.0 of the SDK, if the define PICO_MUTEX_ENABLE_SDK120_COMPATIBILITY is set to 1, then the the regular mutex_ functions may also be used for recursive mutexes. This flag will be removed in a future version of the SDK.</p>
<p>See <a class="el" href="critical__section_8h.html">critical_section.h</a> for protecting access between multiple cores AND IRQ handlers </p>
<h2 class="groupheader">Documentação das macros</h2>
<a id="gaa1b5d9dea897013fc5e40bf102045592" name="gaa1b5d9dea897013fc5e40bf102045592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b5d9dea897013fc5e40bf102045592">&#9670;&#160;</a></span>auto_init_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">define</a> auto_init_mutex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">static</a> <a class="el" href="group__pico__bootrom.html#gaa0d8e5afb2db73425ff3ce85ee0bdbdc">__attribute__</a>((<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">section</a>(&quot;.mutex_array&quot;))) <a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for static definition of mutexes. </p>
<p>A mutex defined as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__mutex.html#gaa1b5d9dea897013fc5e40bf102045592">auto_init_mutex</a>(<a class="code hl_variable" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">my_mutex</a>);</div>
<div class="ttc" id="agroup__mutex_html_gaa1b5d9dea897013fc5e40bf102045592"><div class="ttname"><a href="group__mutex.html#gaa1b5d9dea897013fc5e40bf102045592">auto_init_mutex</a></div><div class="ttdeci">#define auto_init_mutex(name)</div><div class="ttdoc">Helper macro for static definition of mutexes.</div><div class="ttdef"><b>Definição</b> mutex.h:283</div></div>
<div class="ttc" id="apico__divider__nesting__test_8c_html_a0b4d1ad82ace098e820dde96e7e393e2"><div class="ttname"><a href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">count</a></div><div class="ttdeci">volatile uint32_t count[3]</div><div class="ttdef"><b>Definição</b> pico_divider_nesting_test.c:16</div></div>
</div><!-- fragment --><p>Is equivalent to doing</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structmutex.html">mutex_t</a> <a class="code hl_variable" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">my_mutex</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_variable" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">my_init_function</a>() {</div>
<div class="line">   <a class="code hl_function" href="group__mutex.html#gabe21d7ce624db2df7afe86c4bba400a2">mutex_init</a>(&amp;<a class="code hl_variable" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">my_mutex</a>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__mutex_html_gabe21d7ce624db2df7afe86c4bba400a2"><div class="ttname"><a href="group__mutex.html#gabe21d7ce624db2df7afe86c4bba400a2">mutex_init</a></div><div class="ttdeci">void mutex_init(mutex_t *mtx)</div><div class="ttdoc">Initialise a mutex structure.</div><div class="ttdef"><b>Definição</b> mutex.c:43</div></div>
<div class="ttc" id="astructmutex_html"><div class="ttname"><a href="structmutex.html">mutex</a></div><div class="ttdoc">regular (non recursive) mutex instance</div><div class="ttdef"><b>Definição</b> mutex.h:60</div></div>
</div><!-- fragment --><p>But the initialization of the mutex is performed automatically during runtime initialization </p>

</div>
</div>
<a id="ga3c019cd595a52ee87e06bdf20e427660" name="ga3c019cd595a52ee87e06bdf20e427660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c019cd595a52ee87e06bdf20e427660">&#9670;&#160;</a></span>auto_init_recursive_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">define</a> auto_init_recursive_mutex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">static</a> <a class="el" href="group__pico__bootrom.html#gaa0d8e5afb2db73425ff3ce85ee0bdbdc">__attribute__</a>((<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">section</a>(&quot;.mutex_array&quot;))) <a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> name = { .core = { .spin_lock = (<a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a96af910e1f1911aa6eb0b9f84410a151">spin_lock_t</a> *)1 /* <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">marker</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">for</a> <a class="el" href="group__pico__runtime.html#gad27ee86dcd85855022a424f61b839d04">runtime_init</a> */ }, .owner = 0, .enter_count = 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for static definition of recursive mutexes. </p>
<p>A recursive mutex defined as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__mutex.html#ga3c019cd595a52ee87e06bdf20e427660">auto_init_recursive_mutex</a>(<a class="code hl_variable" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">my_recursive_mutex</a>);</div>
<div class="ttc" id="agroup__mutex_html_ga3c019cd595a52ee87e06bdf20e427660"><div class="ttname"><a href="group__mutex.html#ga3c019cd595a52ee87e06bdf20e427660">auto_init_recursive_mutex</a></div><div class="ttdeci">#define auto_init_recursive_mutex(name)</div><div class="ttdoc">Helper macro for static definition of recursive mutexes.</div><div class="ttdef"><b>Definição</b> mutex.h:306</div></div>
</div><!-- fragment --><p>Is equivalent to doing</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structrecursive__mutex__t.html">recursive_mutex_t</a> <a class="code hl_variable" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">my_recursive_mutex</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_variable" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">my_init_function</a>() {</div>
<div class="line">   <a class="code hl_function" href="group__mutex.html#ga30d1f9d58564a1799e293451edc2d28e">recursive_mutex_init</a>(&amp;<a class="code hl_variable" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">my_recursive_mutex</a>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__mutex_html_ga30d1f9d58564a1799e293451edc2d28e"><div class="ttname"><a href="group__mutex.html#ga30d1f9d58564a1799e293451edc2d28e">recursive_mutex_init</a></div><div class="ttdeci">void recursive_mutex_init(recursive_mutex_t *mtx)</div><div class="ttdoc">Initialise a recursive mutex structure.</div><div class="ttdef"><b>Definição</b> mutex.c:52</div></div>
<div class="ttc" id="astructrecursive__mutex__t_html"><div class="ttname"><a href="structrecursive__mutex__t.html">recursive_mutex_t</a></div><div class="ttdoc">recursive mutex instance</div><div class="ttdef"><b>Definição</b> mutex.h:47</div></div>
</div><!-- fragment --><p>But the initialization of the mutex is performed automatically during runtime initialization </p>

</div>
</div>
<h2 class="groupheader">Documentação dos tipos</h2>
<a id="gac32ff6793a910bc7b48c8b0bb3c47ea7" name="gac32ff6793a910bc7b48c8b0bb3c47ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32ff6793a910bc7b48c8b0bb3c47ea7">&#9670;&#160;</a></span>mutex_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">typedef</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">struct</a> <a class="el" href="structmutex.html">mutex</a> <a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>regular (non recursive) mutex instance </p>

</div>
</div>
<h2 class="groupheader">Documentação das funções</h2>
<a id="ga69e2f75f0a38378b20c0f2bf9cc7bbe3" name="ga69e2f75f0a38378b20c0f2bf9cc7bbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">&#9670;&#160;</a></span>mutex_enter_block_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> mutex_enter_block_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common_2pico__base__headers_2include_2pico_2types_8h.html#afd2047ec52f48f0e893289f03ec5bf5e">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for mutex until a specific time. </p>
<p>Wait until the specific time to take ownership of the mutex. If the caller can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">until</td><td>The time after which to return if the caller cannot be granted ownership of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if mutex now owned, false if timeout occurred before ownership could be granted </dd></dl>

<p class="reference">Referências <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>, <a class="el" href="group__lock__core.html#ga627a09221ed61634d6dfea6f406e104e">lock_internal_spin_unlock_with_best_effort_wait_or_timeout</a>, <a class="el" href="lock__core_8h.html#ad11a50437318f92a9e0b9ae6ff088300">lock_is_owner_id_valid</a>, <a class="el" href="group__lock__core.html#ga7e5b614312aabaada704b6a2350d39bc">lock_owner_id_t</a>, <a class="el" href="group__mutex.html#ga6ce3ca26cbce71a3e29396264e00e253">recursive_mutex_enter_block_until()</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a7d2876d2a555a0646b354742db81a519">spin_lock_blocking()</a> e <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#af4df3e7b60025a90629ee322fec8bc8f">spin_unlock()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="group__mutex.html#ga32c6e468289a81a49b4bde50a6280f83">mutex_enter_timeout_ms()</a>, <a class="el" href="group__mutex.html#ga553f33e9692a19f8ad956a8b770858e0">mutex_enter_timeout_us()</a> e <a class="el" href="group__mutex.html#ga91088e6bd3929dcf86ed12cd92ee2cd8">mutex_try_enter_block_until()</a>.</p>

</div>
</div>
<a id="ga65b1c7af0545f478c80b51513d8f6993" name="ga65b1c7af0545f478c80b51513d8f6993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65b1c7af0545f478c80b51513d8f6993">&#9670;&#160;</a></span>mutex_enter_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> mutex_enter_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take ownership of a mutex. </p>
<p>This function will block until the caller can be granted ownership of the mutex. On return the caller owns the mutex</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referências <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>, <a class="el" href="group__lock__core.html#gaaea64ba43b0ff683739ba136fe5a2b29">lock_internal_spin_unlock_with_wait</a>, <a class="el" href="lock__core_8h.html#ad11a50437318f92a9e0b9ae6ff088300">lock_is_owner_id_valid</a>, <a class="el" href="group__lock__core.html#ga7e5b614312aabaada704b6a2350d39bc">lock_owner_id_t</a>, <a class="el" href="group__mutex.html#gad11f3d954d96cfdc77025735d35983e1">recursive_mutex_enter_blocking()</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a7d2876d2a555a0646b354742db81a519">spin_lock_blocking()</a> e <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#af4df3e7b60025a90629ee322fec8bc8f">spin_unlock()</a>.</p>

</div>
</div>
<a id="ga32c6e468289a81a49b4bde50a6280f83" name="ga32c6e468289a81a49b4bde50a6280f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32c6e468289a81a49b4bde50a6280f83">&#9670;&#160;</a></span>mutex_enter_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> mutex_enter_timeout_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for mutex with timeout. </p>
<p>Wait for up to the specific time to take ownership of the mutex. If the caller can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if mutex now owned, false if timeout occurred before ownership could be granted </dd></dl>

<p class="reference">Referências <a class="el" href="group__mutex.html#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">mutex_enter_block_until()</a>.</p>

</div>
</div>
<a id="ga553f33e9692a19f8ad956a8b770858e0" name="ga553f33e9692a19f8ad956a8b770858e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga553f33e9692a19f8ad956a8b770858e0">&#9670;&#160;</a></span>mutex_enter_timeout_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> mutex_enter_timeout_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for mutex with timeout. </p>
<p>Wait for up to the specific time to take ownership of the mutex. If the caller can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">timeout_us</td><td>The timeout in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if mutex now owned, false if timeout occurred before ownership could be granted </dd></dl>

<p class="reference">Referências <a class="el" href="group__mutex.html#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">mutex_enter_block_until()</a>.</p>

</div>
</div>
<a id="gaf528c8fbb5f4532758859d18e24e1673" name="gaf528c8fbb5f4532758859d18e24e1673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf528c8fbb5f4532758859d18e24e1673">&#9670;&#160;</a></span>mutex_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> mutex_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ownership of a mutex. </p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referências <a class="el" href="group__lock__core.html#ga298f38f465c9115393f0f35f56c13279">lock_internal_spin_unlock_with_notify</a>, <a class="el" href="group__lock__core.html#ga56aa223ceb22fdc4f0a3464fff119e14">LOCK_INVALID_OWNER_ID</a>, <a class="el" href="lock__core_8h.html#ad11a50437318f92a9e0b9ae6ff088300">lock_is_owner_id_valid</a>, <a class="el" href="group__mutex.html#ga2f75321a04ba731f5875353fbaebc345">recursive_mutex_exit()</a> e <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a7d2876d2a555a0646b354742db81a519">spin_lock_blocking()</a>.</p>

</div>
</div>
<a id="gabe21d7ce624db2df7afe86c4bba400a2" name="gabe21d7ce624db2df7afe86c4bba400a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe21d7ce624db2df7afe86c4bba400a2">&#9670;&#160;</a></span>mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a mutex structure. </p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referências <a class="el" href="structmutex.html#a565cec67c5756833fbb6d4980da56c3f">core</a>, <a class="el" href="group__lock__core.html#gabc062dfb52c8f7f17ec8427d1c4414d9">lock_init()</a>, <a class="el" href="group__lock__core.html#ga56aa223ceb22fdc4f0a3464fff119e14">LOCK_INVALID_OWNER_ID</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#ada80522f47eff861a28a0c702c55e7b5">next_striped_spin_lock_num()</a> e <a class="el" href="structmutex.html#aafc2ca2bf0c4d62f6616e848c5307c57">owner</a>.</p>

<p class="reference">Referenciado por <a class="el" href="mutex_8h.html#ac23028c923e78aa44de6d9102d209a6c">runtime_init_mutex()</a>.</p>

</div>
</div>
<a id="gaa116de2f28fd7df8fb78b210e07b1ed4" name="gaa116de2f28fd7df8fb78b210e07b1ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa116de2f28fd7df8fb78b210e07b1ed4">&#9670;&#160;</a></span>mutex_try_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> mutex_try_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>owner_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to take ownership of a mutex. </p>
<p>If the mutex wasn't owned, this will claim the mutex for the caller and return true. Otherwise (if the mutex was already owned) this will return false and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">owner_out</td><td>If mutex was already owned, and this pointer is non-zero, it will be filled in with the owner id of the current owner of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if mutex now owned, false otherwise </dd></dl>

<p class="reference">Referências <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>, <a class="el" href="lock__core_8h.html#ad11a50437318f92a9e0b9ae6ff088300">lock_is_owner_id_valid</a>, <a class="el" href="group__mutex.html#gae431bbb90e45cf9ae47130a5635aa2b0">recursive_mutex_try_enter()</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a7d2876d2a555a0646b354742db81a519">spin_lock_blocking()</a> e <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#af4df3e7b60025a90629ee322fec8bc8f">spin_unlock()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="kitchen__sink_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a> e <a class="el" href="group__mutex.html#ga91088e6bd3929dcf86ed12cd92ee2cd8">mutex_try_enter_block_until()</a>.</p>

</div>
</div>
<a id="ga91088e6bd3929dcf86ed12cd92ee2cd8" name="ga91088e6bd3929dcf86ed12cd92ee2cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91088e6bd3929dcf86ed12cd92ee2cd8">&#9670;&#160;</a></span>mutex_try_enter_block_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> mutex_try_enter_block_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common_2pico__base__headers_2include_2pico_2types_8h.html#afd2047ec52f48f0e893289f03ec5bf5e">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to take ownership of a mutex until the specified time. </p>
<p>If the mutex wasn't owned, this method will immediately claim the mutex for the caller and return true. If the mutex is owned by the caller, this method will immediately return false, If the mutex is owned by someone else, this method will try to claim it until the specified time, returning true if it succeeds, or false on timeout</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">until</td><td>The time after which to return if the caller cannot be granted ownership of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if mutex now owned, false otherwise </dd></dl>

<p class="reference">Referências <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>, <a class="el" href="group__lock__core.html#ga7e5b614312aabaada704b6a2350d39bc">lock_owner_id_t</a>, <a class="el" href="group__mutex.html#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">mutex_enter_block_until()</a> e <a class="el" href="group__mutex.html#gaa116de2f28fd7df8fb78b210e07b1ed4">mutex_try_enter()</a>.</p>

</div>
</div>
<a id="ga6ce3ca26cbce71a3e29396264e00e253" name="ga6ce3ca26cbce71a3e29396264e00e253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce3ca26cbce71a3e29396264e00e253">&#9670;&#160;</a></span>recursive_mutex_enter_block_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> recursive_mutex_enter_block_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common_2pico__base__headers_2include_2pico_2types_8h.html#afd2047ec52f48f0e893289f03ec5bf5e">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for mutex until a specific time. </p>
<p>Wait until the specific time to take ownership of the mutex. If the caller already has ownership of the mutex or can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
    <tr><td class="paramname">until</td><td>The time after which to return if the caller cannot be granted ownership of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if the recursive mutex (now) owned, false if timeout occurred before ownership could be granted </dd></dl>

<p class="reference">Referências <a class="el" href="host_2pico__platform_2include_2pico_2platform_8h.html#a2e3484535ee610c8e19e9859563abe48">__unused</a>, <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>, <a class="el" href="group__lock__core.html#ga627a09221ed61634d6dfea6f406e104e">lock_internal_spin_unlock_with_best_effort_wait_or_timeout</a>, <a class="el" href="lock__core_8h.html#ad11a50437318f92a9e0b9ae6ff088300">lock_is_owner_id_valid</a>, <a class="el" href="group__lock__core.html#ga7e5b614312aabaada704b6a2350d39bc">lock_owner_id_t</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a7d2876d2a555a0646b354742db81a519">spin_lock_blocking()</a> e <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#af4df3e7b60025a90629ee322fec8bc8f">spin_unlock()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="group__mutex.html#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">mutex_enter_block_until()</a>, <a class="el" href="group__mutex.html#gad54a0bdb7967571caecb62869bd4194d">recursive_mutex_enter_timeout_ms()</a> e <a class="el" href="group__mutex.html#gaeeb630a7c13ed3adc567e62c8c737401">recursive_mutex_enter_timeout_us()</a>.</p>

</div>
</div>
<a id="gad11f3d954d96cfdc77025735d35983e1" name="gad11f3d954d96cfdc77025735d35983e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad11f3d954d96cfdc77025735d35983e1">&#9670;&#160;</a></span>recursive_mutex_enter_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> recursive_mutex_enter_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take ownership of a recursive mutex. </p>
<p>This function will block until the caller can be granted ownership of the mutex. On return the caller owns the mutex</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referências <a class="el" href="host_2pico__platform_2include_2pico_2platform_8h.html#a2e3484535ee610c8e19e9859563abe48">__unused</a>, <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>, <a class="el" href="group__lock__core.html#gaaea64ba43b0ff683739ba136fe5a2b29">lock_internal_spin_unlock_with_wait</a>, <a class="el" href="lock__core_8h.html#ad11a50437318f92a9e0b9ae6ff088300">lock_is_owner_id_valid</a>, <a class="el" href="group__lock__core.html#ga7e5b614312aabaada704b6a2350d39bc">lock_owner_id_t</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a7d2876d2a555a0646b354742db81a519">spin_lock_blocking()</a> e <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#af4df3e7b60025a90629ee322fec8bc8f">spin_unlock()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="group__mutex.html#ga65b1c7af0545f478c80b51513d8f6993">mutex_enter_blocking()</a>.</p>

</div>
</div>
<a id="gad54a0bdb7967571caecb62869bd4194d" name="gad54a0bdb7967571caecb62869bd4194d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54a0bdb7967571caecb62869bd4194d">&#9670;&#160;</a></span>recursive_mutex_enter_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> recursive_mutex_enter_timeout_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for recursive mutex with timeout. </p>
<p>Wait for up to the specific time to take ownership of the recursive mutex. If the caller already has ownership of the mutex or can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if the recursive mutex (now) owned, false if timeout occurred before ownership could be granted </dd></dl>

<p class="reference">Referências <a class="el" href="group__mutex.html#ga6ce3ca26cbce71a3e29396264e00e253">recursive_mutex_enter_block_until()</a>.</p>

</div>
</div>
<a id="gaeeb630a7c13ed3adc567e62c8c737401" name="gaeeb630a7c13ed3adc567e62c8c737401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb630a7c13ed3adc567e62c8c737401">&#9670;&#160;</a></span>recursive_mutex_enter_timeout_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> recursive_mutex_enter_timeout_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for recursive mutex with timeout. </p>
<p>Wait for up to the specific time to take ownership of the recursive mutex. If the caller already has ownership of the mutex or can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">timeout_us</td><td>The timeout in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if the recursive mutex (now) owned, false if timeout occurred before ownership could be granted </dd></dl>

<p class="reference">Referências <a class="el" href="group__mutex.html#ga6ce3ca26cbce71a3e29396264e00e253">recursive_mutex_enter_block_until()</a>.</p>

</div>
</div>
<a id="ga2f75321a04ba731f5875353fbaebc345" name="ga2f75321a04ba731f5875353fbaebc345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f75321a04ba731f5875353fbaebc345">&#9670;&#160;</a></span>recursive_mutex_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> recursive_mutex_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ownership of a recursive mutex. </p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referências <a class="el" href="group__lock__core.html#ga298f38f465c9115393f0f35f56c13279">lock_internal_spin_unlock_with_notify</a>, <a class="el" href="group__lock__core.html#ga56aa223ceb22fdc4f0a3464fff119e14">LOCK_INVALID_OWNER_ID</a>, <a class="el" href="lock__core_8h.html#ad11a50437318f92a9e0b9ae6ff088300">lock_is_owner_id_valid</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a7d2876d2a555a0646b354742db81a519">spin_lock_blocking()</a> e <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#af4df3e7b60025a90629ee322fec8bc8f">spin_unlock()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="group__mutex.html#gaf528c8fbb5f4532758859d18e24e1673">mutex_exit()</a>.</p>

</div>
</div>
<a id="ga30d1f9d58564a1799e293451edc2d28e" name="ga30d1f9d58564a1799e293451edc2d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d1f9d58564a1799e293451edc2d28e">&#9670;&#160;</a></span>recursive_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> recursive_mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a recursive mutex structure. </p>
<p>A recursive mutex may be entered in a nested fashion by the same owner</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referências <a class="el" href="structrecursive__mutex__t.html#a198df3efb758b19989cf7815b04bfdac">recursive_mutex_t::core</a>, <a class="el" href="structrecursive__mutex__t.html#a8e45994023c81c6f2933380905fa316e">recursive_mutex_t::enter_count</a>, <a class="el" href="group__lock__core.html#gabc062dfb52c8f7f17ec8427d1c4414d9">lock_init()</a>, <a class="el" href="group__lock__core.html#ga56aa223ceb22fdc4f0a3464fff119e14">LOCK_INVALID_OWNER_ID</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#ada80522f47eff861a28a0c702c55e7b5">next_striped_spin_lock_num()</a> e <a class="el" href="structrecursive__mutex__t.html#a9e31f78fdd7b58548e51d9b21f6bff28">recursive_mutex_t::owner</a>.</p>

<p class="reference">Referenciado por <a class="el" href="group__async__context__threadsafe__background.html#gabf48cafcbfa48c9fbef1aa7a18ded9e5">async_context_threadsafe_background_init()</a> e <a class="el" href="mutex_8h.html#ac23028c923e78aa44de6d9102d209a6c">runtime_init_mutex()</a>.</p>

</div>
</div>
<a id="gae431bbb90e45cf9ae47130a5635aa2b0" name="gae431bbb90e45cf9ae47130a5635aa2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae431bbb90e45cf9ae47130a5635aa2b0">&#9670;&#160;</a></span>recursive_mutex_try_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> recursive_mutex_try_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>owner_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to take ownership of a recursive mutex. </p>
<p>If the mutex wasn't owned or was owned by the caller, this will claim the mutex and return true. Otherwise (if the mutex was already owned by another owner) this will return false and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
    <tr><td class="paramname">owner_out</td><td>If mutex was already owned by another owner, and this pointer is non-zero, it will be filled in with the owner id of the current owner of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>true if the recursive mutex (now) owned, false otherwise </dd></dl>

<p class="reference">Referências <a class="el" href="host_2pico__platform_2include_2pico_2platform_8h.html#a2e3484535ee610c8e19e9859563abe48">__unused</a>, <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>, <a class="el" href="lock__core_8h.html#ad11a50437318f92a9e0b9ae6ff088300">lock_is_owner_id_valid</a>, <a class="el" href="group__lock__core.html#ga7e5b614312aabaada704b6a2350d39bc">lock_owner_id_t</a>, <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#a7d2876d2a555a0646b354742db81a519">spin_lock_blocking()</a> e <a class="el" href="host_2hardware__sync_2include_2hardware_2sync_8h.html#af4df3e7b60025a90629ee322fec8bc8f">spin_unlock()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="kitchen__sink_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a> e <a class="el" href="group__mutex.html#gaa116de2f28fd7df8fb78b210e07b1ed4">mutex_try_enter()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Gerado por <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
