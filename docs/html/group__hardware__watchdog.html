<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RP2040 OLED SSD1306: hardware_watchdog</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RP2040 OLED SSD1306
   </div>
   <div id="projectbrief">Driver/Exemplos para display OLED SSD1306 no RP2040</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Gerado por Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Localizar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__hardware__watchdog.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Carregando...</div>
<div class="SRStatus" id="Searching">Procurando...</div>
<div class="SRStatus" id="NoMatches">Nenhuma entrada encontrada</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Funções</a>  </div>
  <div class="headertitle"><div class="title">hardware_watchdog</div></div>
</div><!--header-->
<div class="contents">

<p>Hardware Watchdog Timer API.  
<a href="#details">Mais...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Funções</h2></td></tr>
<tr class="memitem:ga65f5d24169045b8c7dc709e572535d94" id="r_ga65f5d24169045b8c7dc709e572535d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">watchdog_caused_reboot</a> (<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>)</td></tr>
<tr class="memdesc:ga65f5d24169045b8c7dc709e572535d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did the watchdog cause the last reboot?  <br /></td></tr>
<tr class="separator:ga65f5d24169045b8c7dc709e572535d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad627aed933db1187ad21853494dbe18d" id="r_gad627aed933db1187ad21853494dbe18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#gad627aed933db1187ad21853494dbe18d">watchdog_disable</a> (<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>)</td></tr>
<tr class="memdesc:gad627aed933db1187ad21853494dbe18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the watchdog.  <br /></td></tr>
<tr class="separator:gad627aed933db1187ad21853494dbe18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87042933bd6c335c21131991c83c161d" id="r_ga87042933bd6c335c21131991c83c161d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a> (<a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">delay_ms</a>, <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">pause_on_debug</a>)</td></tr>
<tr class="memdesc:ga87042933bd6c335c21131991c83c161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the watchdog.  <br /></td></tr>
<tr class="separator:ga87042933bd6c335c21131991c83c161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455aa48ca6f11298e184d2ae0e81a085" id="r_ga455aa48ca6f11298e184d2ae0e81a085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga455aa48ca6f11298e184d2ae0e81a085">watchdog_enable_caused_reboot</a> (<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>)</td></tr>
<tr class="memdesc:ga455aa48ca6f11298e184d2ae0e81a085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did watchdog_enable cause the last reboot?  <br /></td></tr>
<tr class="separator:ga455aa48ca6f11298e184d2ae0e81a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga536c4f5fbb5a967852b4fc8c4d2020bb" id="r_ga536c4f5fbb5a967852b4fc8c4d2020bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga536c4f5fbb5a967852b4fc8c4d2020bb">watchdog_get_time_remaining_ms</a> (<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>)</td></tr>
<tr class="memdesc:ga536c4f5fbb5a967852b4fc8c4d2020bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of milliseconds before the watchdog will reboot the chip.  <br /></td></tr>
<tr class="separator:ga536c4f5fbb5a967852b4fc8c4d2020bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabba4e8fa01f2ff2e5a9fbba4e9d2d86d" id="r_gabba4e8fa01f2ff2e5a9fbba4e9d2d86d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#gabba4e8fa01f2ff2e5a9fbba4e9d2d86d">watchdog_get_time_remaining_us</a> (<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>)</td></tr>
<tr class="memdesc:gabba4e8fa01f2ff2e5a9fbba4e9d2d86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of microseconds before the watchdog will reboot the chip.  <br /></td></tr>
<tr class="separator:gabba4e8fa01f2ff2e5a9fbba4e9d2d86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73ccd43d6d755817e71bc3d7eb1fda6" id="r_gaa73ccd43d6d755817e71bc3d7eb1fda6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#gaa73ccd43d6d755817e71bc3d7eb1fda6">watchdog_reboot</a> (<a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> <a class="el" href="pio__types_8h.html#a79ae533555e4c4c96a036032b461dd44abc54f4d60f1cec0f9a6cb70e13f2127a">pc</a>, <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">sp</a>, <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">delay_ms</a>)</td></tr>
<tr class="memdesc:gaa73ccd43d6d755817e71bc3d7eb1fda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define actions to perform at watchdog timeout.  <br /></td></tr>
<tr class="separator:gaa73ccd43d6d755817e71bc3d7eb1fda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9cfb964649bc7928c72335d964e425" id="r_gaab9cfb964649bc7928c72335d964e425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> (<a class="el" href="common_2pico__base__headers_2include_2pico_2types_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cycles)</td></tr>
<tr class="memdesc:gaab9cfb964649bc7928c72335d964e425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the watchdog tick.  <br /></td></tr>
<tr class="separator:gaab9cfb964649bc7928c72335d964e425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329b748919954f8b48c58049115a5c54" id="r_ga329b748919954f8b48c58049115a5c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga329b748919954f8b48c58049115a5c54">watchdog_update</a> (<a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>)</td></tr>
<tr class="memdesc:ga329b748919954f8b48c58049115a5c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload the watchdog counter with the amount of time set in watchdog_enable.  <br /></td></tr>
<tr class="separator:ga329b748919954f8b48c58049115a5c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrição detalhada</h2>
<p>Hardware Watchdog Timer API. </p>
<p>Supporting functions for the Pico hardware watchdog timer.</p>
<p>The RP-series microcontrollers have a built in HW watchdog Timer. This is a countdown timer that can restart parts of the chip if it reaches zero. For example, this can be used to restart the processor if the software running on it gets stuck in an infinite loop or similar. The programmer has to periodically write a value to the watchdog to stop it reaching zero.</p>
<h2><a class="anchor" id="watchdog_example"></a>
Example</h2>
<div class="fragment"></div><!-- fragment --> <h2 class="groupheader">Documentação das funções</h2>
<a id="ga65f5d24169045b8c7dc709e572535d94" name="ga65f5d24169045b8c7dc709e572535d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65f5d24169045b8c7dc709e572535d94">&#9670;&#160;</a></span>watchdog_caused_reboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> watchdog_caused_reboot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did the watchdog cause the last reboot? </p>
<dl class="section return"><dt>Retorna</dt><dd>true If the watchdog timer or a watchdog force caused the last reboot </dd>
<dd>
false If there has been no watchdog reboot since the last power on reset. A power on reset is typically caused by a power cycle or the run pin (reset button) being toggled. </dd></dl>

<p class="reference">Referências <a class="el" href="boot__bootrom__headers_2include_2boot_2bootrom__constants_8h.html#a1e81e5e2d9b0e0ad5f1df84d7ece0493">BOOT_TYPE_NORMAL</a> e <a class="el" href="rp2040_2hardware__structs_2include_2hardware_2structs_2watchdog_8h.html#a3c40c3f45c4ce2ee6183686319f787d3">watchdog_hw</a>.</p>

</div>
</div>
<a id="gad627aed933db1187ad21853494dbe18d" name="gad627aed933db1187ad21853494dbe18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad627aed933db1187ad21853494dbe18d">&#9670;&#160;</a></span>watchdog_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> watchdog_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the watchdog. </p>

<p class="reference">Referências <a class="el" href="rp2040_2hardware__regs_2include_2hardware_2regs_2watchdog_8h.html#af779cf310a8dc9a3346331c50083d252">WATCHDOG_CTRL_ENABLE_BITS</a> e <a class="el" href="rp2040_2hardware__structs_2include_2hardware_2structs_2watchdog_8h.html#a3c40c3f45c4ce2ee6183686319f787d3">watchdog_hw</a>.</p>

</div>
</div>
<a id="ga87042933bd6c335c21131991c83c161d" name="ga87042933bd6c335c21131991c83c161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87042933bd6c335c21131991c83c161d">&#9670;&#160;</a></span>watchdog_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> watchdog_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>delay_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a>&#160;</td>
          <td class="paramname"><em>pause_on_debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the watchdog. </p>
<dl class="section note"><dt>Nota</dt><dd>If <a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> value does not give a 1MHz clock to the watchdog system, then the <code>delay_ms</code> parameter will not be in milliseconds. See the datasheet for more details.</dd></dl>
<p>By default the SDK assumes a 12MHz XOSC and sets the <a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> appropriately.</p>
<p>This method sets a marker in the watchdog scratch register 4 that is checked by <a class="el" href="group__hardware__watchdog.html#ga455aa48ca6f11298e184d2ae0e81a085">watchdog_enable_caused_reboot</a>. If the device is subsequently reset via a call to watchdog_reboot (including for example by dragging a UF2 onto the RPI-RP2), then this value will be cleared, and so <a class="el" href="group__hardware__watchdog.html#ga455aa48ca6f11298e184d2ae0e81a085">watchdog_enable_caused_reboot</a> will return false.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_ms</td><td>Number of milliseconds before watchdog will reboot without watchdog_update being called </td></tr>
    <tr><td class="paramname">pause_on_debug</td><td>If the watchdog should be paused when the debugger is stepping through code </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referências <a class="el" href="watchdog_8c.html#a4a9677d9f77330cca548b33f6597d531">_watchdog_enable()</a>, <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">count</a>, <a class="el" href="rp2040_2hardware__structs_2include_2hardware_2structs_2watchdog_8h.html#a3c40c3f45c4ce2ee6183686319f787d3">watchdog_hw</a> e <a class="el" href="watchdog_8c.html#afe273d75c031a563c8355a15d2a11ec9">WATCHDOG_NON_REBOOT_MAGIC</a>.</p>

</div>
</div>
<a id="ga455aa48ca6f11298e184d2ae0e81a085" name="ga455aa48ca6f11298e184d2ae0e81a085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455aa48ca6f11298e184d2ae0e81a085">&#9670;&#160;</a></span>watchdog_enable_caused_reboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">bool</a> watchdog_enable_caused_reboot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did watchdog_enable cause the last reboot? </p>
<p>Perform additional checking along with <a class="el" href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">watchdog_caused_reboot</a> to determine if a watchdog timeout initiated by <a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a> caused the last reboot.</p>
<p>This method checks for a special value in watchdog scratch register 4 placed there by <a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a>. This would not be present if a watchdog reset is initiated by <a class="el" href="group__hardware__watchdog.html#gaa73ccd43d6d755817e71bc3d7eb1fda6">watchdog_reboot</a> or by the RP-series microcontroller bootrom (e.g. dragging a UF2 onto the RPI-RP2 drive).</p>
<dl class="section return"><dt>Retorna</dt><dd>true If the watchdog timer or a watchdog force caused (see <a class="el" href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">watchdog_caused_reboot</a>) the last reboot and the watchdog reboot happened after <a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a> was called </dd>
<dd>
false If there has been no watchdog reboot since the last power on reset, or the watchdog reboot was not caused by a watchdog timeout after <a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a> was called. A power on reset is typically caused by a power cycle or the run pin (reset button) being toggled. </dd></dl>

<p class="reference">Referências <a class="el" href="rp2040_2hardware__structs_2include_2hardware_2structs_2watchdog_8h.html#a3c40c3f45c4ce2ee6183686319f787d3">watchdog_hw</a> e <a class="el" href="watchdog_8c.html#afe273d75c031a563c8355a15d2a11ec9">WATCHDOG_NON_REBOOT_MAGIC</a>.</p>

</div>
</div>
<a id="ga536c4f5fbb5a967852b4fc8c4d2020bb" name="ga536c4f5fbb5a967852b4fc8c4d2020bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga536c4f5fbb5a967852b4fc8c4d2020bb">&#9670;&#160;</a></span>watchdog_get_time_remaining_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> watchdog_get_time_remaining_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of milliseconds before the watchdog will reboot the chip. </p>
<dl class="section return"><dt>Retorna</dt><dd>The number of milliseconds before the watchdog will reboot the chip. </dd></dl>

<p class="reference">Referências <a class="el" href="rp2040_2hardware__regs_2include_2hardware_2regs_2watchdog_8h.html#a2db6ccf1f746d182591768cb27d049ee">WATCHDOG_CTRL_TIME_BITS</a>, <a class="el" href="rp2040_2hardware__structs_2include_2hardware_2structs_2watchdog_8h.html#a3c40c3f45c4ce2ee6183686319f787d3">watchdog_hw</a> e <a class="el" href="watchdog_8c.html#adda96262949916f27c86e1971bce6443">WATCHDOG_XFACTOR</a>.</p>

</div>
</div>
<a id="gabba4e8fa01f2ff2e5a9fbba4e9d2d86d" name="gabba4e8fa01f2ff2e5a9fbba4e9d2d86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabba4e8fa01f2ff2e5a9fbba4e9d2d86d">&#9670;&#160;</a></span>watchdog_get_time_remaining_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> watchdog_get_time_remaining_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of microseconds before the watchdog will reboot the chip. </p>
<dl class="section return"><dt>Retorna</dt><dd>The number of microseconds before the watchdog will reboot the chip. </dd></dl>

<p class="reference">Referências <a class="el" href="rp2040_2hardware__regs_2include_2hardware_2regs_2watchdog_8h.html#a2db6ccf1f746d182591768cb27d049ee">WATCHDOG_CTRL_TIME_BITS</a>, <a class="el" href="rp2040_2hardware__structs_2include_2hardware_2structs_2watchdog_8h.html#a3c40c3f45c4ce2ee6183686319f787d3">watchdog_hw</a> e <a class="el" href="watchdog_8c.html#adda96262949916f27c86e1971bce6443">WATCHDOG_XFACTOR</a>.</p>

</div>
</div>
<a id="gaa73ccd43d6d755817e71bc3d7eb1fda6" name="gaa73ccd43d6d755817e71bc3d7eb1fda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa73ccd43d6d755817e71bc3d7eb1fda6">&#9670;&#160;</a></span>watchdog_reboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> watchdog_reboot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>delay_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define actions to perform at watchdog timeout. </p>
<dl class="section note"><dt>Nota</dt><dd>If <a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> value does not give a 1MHz clock to the watchdog system, then the <code>delay_ms</code> parameter will not be in milliseconds. See the datasheet for more details.</dd></dl>
<p>By default the SDK assumes a 12MHz XOSC and sets the <a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> appropriately.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">pc</td><td>If Zero, a standard boot will be performed, if non-zero this is the program counter to jump to on reset. </td></tr>
    <tr><td class="paramname">sp</td><td>If <code>pc</code> is non-zero, this will be the stack pointer used. </td></tr>
    <tr><td class="paramname">delay_ms</td><td>Initial load value. Maximum value 8388, approximately 8.3s. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referências <a class="el" href="watchdog_8c.html#a4a9677d9f77330cca548b33f6597d531">_watchdog_enable()</a>, <a class="el" href="address__mapped_8h.html#a9826c1f71b818d793a34e4d4c4198bc1">check_hw_layout</a>, <a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">count</a>, <a class="el" href="pio__types_8h.html#a79ae533555e4c4c96a036032b461dd44abc54f4d60f1cec0f9a6cb70e13f2127a">pc</a>, <a class="el" href="rp2040_2hardware__regs_2include_2hardware_2regs_2watchdog_8h.html#af779cf310a8dc9a3346331c50083d252">WATCHDOG_CTRL_ENABLE_BITS</a>, <a class="el" href="rp2040_2hardware__structs_2include_2hardware_2structs_2watchdog_8h.html#a3c40c3f45c4ce2ee6183686319f787d3">watchdog_hw</a> e <a class="el" href="rp2040_2hardware__regs_2include_2hardware_2regs_2watchdog_8h.html#aa9ce60ef8078a2842fea8960c9610021">WATCHDOG_SCRATCH7_OFFSET</a>.</p>

</div>
</div>
<a id="gaab9cfb964649bc7928c72335d964e425" name="gaab9cfb964649bc7928c72335d964e425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9cfb964649bc7928c72335d964e425">&#9670;&#160;</a></span>watchdog_start_tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> watchdog_start_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="common_2pico__base__headers_2include_2pico_2types_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>cycles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the watchdog tick. </p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>This needs to be a divider that when applied to the XOSC input, produces a 1MHz clock. So if the XOSC is 12MHz, this will need to be 12.</td></tr>
  </table>
  </dd>
</dl>
<p>Start the watchdog tick. </p>

<p class="reference">Referências <a class="el" href="group__hardware__ticks.html#gaea97210ea6cb05be8444eef06c10695a">tick_start()</a> e <a class="el" href="group__hardware__ticks.html#gga7c007d63cabddadd107f9b597278c32eae5a832897214be2a21eb29b5801ddd15">TICK_WATCHDOG</a>.</p>

</div>
</div>
<a id="ga329b748919954f8b48c58049115a5c54" name="ga329b748919954f8b48c58049115a5c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329b748919954f8b48c58049115a5c54">&#9670;&#160;</a></span>watchdog_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a> watchdog_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pico__divider__nesting__test_8c.html#a0b4d1ad82ace098e820dde96e7e393e2">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reload the watchdog counter with the amount of time set in watchdog_enable. </p>

<p class="reference">Referências <a class="el" href="rp2040_2hardware__structs_2include_2hardware_2structs_2watchdog_8h.html#a3c40c3f45c4ce2ee6183686319f787d3">watchdog_hw</a>.</p>

<p class="reference">Referenciado por <a class="el" href="watchdog_8c.html#a4a9677d9f77330cca548b33f6597d531">_watchdog_enable()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Gerado por <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
