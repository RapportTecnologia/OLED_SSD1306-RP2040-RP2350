<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RP2040 OLED SSD1306: Referência à estrutura SIO_Type</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RP2040 OLED SSD1306
   </div>
   <div id="projectbrief">Driver/Exemplos para display OLED SSD1306 no RP2040</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Gerado por Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Localizar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structSIO__Type.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Carregando...</div>
<div class="SRStatus" id="Searching">Procurando...</div>
<div class="SRStatus" id="NoMatches">Nenhuma entrada encontrada</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Atributos Públicos</a> &#124;
<a href="structSIO__Type-members.html">Mostrar lista completa dos membros</a>  </div>
  <div class="headertitle"><div class="title">Referência à estrutura SIO_Type<div class="ingroups"><a class="el" href="group__Raspberry.html">Pi</a> &raquo; <a class="el" href="group__RP2040.html">RP2040</a> &#124; <a class="el" href="group__Raspberry.html">Pi</a> &raquo; <a class="el" href="group__RP2350.html">RP2350</a> &raquo; <a class="el" href="group__Device__Peripheral__peripherals.html">Device_Peripheral_peripherals</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Single-cycle IO block Provides core-local and inter-core hardware for the two processors, with single-cycle access.  
 <a href="structSIO__Type.html#details">Mais...</a></p>

<p><code>#include &lt;<a class="el" href="RP2040_8h_source.html">RP2040.h</a>&gt;</code></p>
<div class="dynheader">
Diagrama de colaboração para SIO_Type:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSIO__Type__coll__graph.svg" width="163" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Atributos Públicos</h2></td></tr>
<tr class="memitem:aeb692e1c4217d833569f3bc5eda2baac" id="r_aeb692e1c4217d833569f3bc5eda2baac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aeb692e1c4217d833569f3bc5eda2baac">CPUID</a></td></tr>
<tr class="memdesc:aeb692e1c4217d833569f3bc5eda2baac"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; SIO Structure <br  />
  <br /></td></tr>
<tr class="separator:aeb692e1c4217d833569f3bc5eda2baac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55046d567803ba2a3f571b221fc738cb" id="r_a55046d567803ba2a3f571b221fc738cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a55046d567803ba2a3f571b221fc738cb">DIV_CSR</a></td></tr>
<tr class="memdesc:a55046d567803ba2a3f571b221fc738cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control and status register for divider.  <br /></td></tr>
<tr class="separator:a55046d567803ba2a3f571b221fc738cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3048037c445d1ede7cda6a7853e65a11" id="r_a3048037c445d1ede7cda6a7853e65a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a3048037c445d1ede7cda6a7853e65a11">DIV_QUOTIENT</a></td></tr>
<tr class="memdesc:a3048037c445d1ede7cda6a7853e65a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divider result quotient The result of <code>DIVIDEND / DIVISOR</code> (division).  <br /></td></tr>
<tr class="separator:a3048037c445d1ede7cda6a7853e65a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cc705f5b2432a89e9b5ae741512a39" id="r_ab3cc705f5b2432a89e9b5ae741512a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ab3cc705f5b2432a89e9b5ae741512a39">DIV_REMAINDER</a></td></tr>
<tr class="memdesc:ab3cc705f5b2432a89e9b5ae741512a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divider result remainder The result of <code>DIVIDEND % DIVISOR</code> (modulo).  <br /></td></tr>
<tr class="separator:ab3cc705f5b2432a89e9b5ae741512a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf296c5f7af423160435fab596f140f0" id="r_abf296c5f7af423160435fab596f140f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#abf296c5f7af423160435fab596f140f0">DIV_SDIVIDEND</a></td></tr>
<tr class="memdesc:abf296c5f7af423160435fab596f140f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divider signed dividend The same as UDIVIDEND, but starts a signed calculation, rather than unsigned.  <br /></td></tr>
<tr class="separator:abf296c5f7af423160435fab596f140f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b20cde79d38f5d1c9370e729a8ef45" id="r_a09b20cde79d38f5d1c9370e729a8ef45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a09b20cde79d38f5d1c9370e729a8ef45">DIV_SDIVISOR</a></td></tr>
<tr class="memdesc:a09b20cde79d38f5d1c9370e729a8ef45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divider signed divisor The same as UDIVISOR, but starts a signed calculation, rather than unsigned.  <br /></td></tr>
<tr class="separator:a09b20cde79d38f5d1c9370e729a8ef45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b2b6921c68180bf82179d2a51a53be" id="r_a18b2b6921c68180bf82179d2a51a53be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a18b2b6921c68180bf82179d2a51a53be">DIV_UDIVIDEND</a></td></tr>
<tr class="memdesc:a18b2b6921c68180bf82179d2a51a53be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divider unsigned dividend Write to the DIVIDEND operand of the divider, i.e.  <br /></td></tr>
<tr class="separator:a18b2b6921c68180bf82179d2a51a53be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5260b2673871962f43552e0bf08b5d" id="r_a5b5260b2673871962f43552e0bf08b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a5b5260b2673871962f43552e0bf08b5d">DIV_UDIVISOR</a></td></tr>
<tr class="memdesc:a5b5260b2673871962f43552e0bf08b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divider unsigned divisor Write to the DIVISOR operand of the divider, i.e.  <br /></td></tr>
<tr class="separator:a5b5260b2673871962f43552e0bf08b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028cb8c35b7250e8a09c8fbcb62cfe49" id="r_a028cb8c35b7250e8a09c8fbcb62cfe49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a028cb8c35b7250e8a09c8fbcb62cfe49">DOORBELL_IN_CLR</a></td></tr>
<tr class="memdesc:a028cb8c35b7250e8a09c8fbcb62cfe49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and acknowledge doorbells posted to this core.  <br /></td></tr>
<tr class="separator:a028cb8c35b7250e8a09c8fbcb62cfe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dae0e5457c91c3ffdd054c9a44cc17" id="r_a74dae0e5457c91c3ffdd054c9a44cc17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a74dae0e5457c91c3ffdd054c9a44cc17">DOORBELL_IN_SET</a></td></tr>
<tr class="memdesc:a74dae0e5457c91c3ffdd054c9a44cc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 1s to trigger doorbell interrupts on this core.  <br /></td></tr>
<tr class="separator:a74dae0e5457c91c3ffdd054c9a44cc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89ff7dc9692ffb340b68bbf9dfc14e8" id="r_ab89ff7dc9692ffb340b68bbf9dfc14e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ab89ff7dc9692ffb340b68bbf9dfc14e8">DOORBELL_OUT_CLR</a></td></tr>
<tr class="memdesc:ab89ff7dc9692ffb340b68bbf9dfc14e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear doorbells which have been posted to the opposite core.  <br /></td></tr>
<tr class="separator:ab89ff7dc9692ffb340b68bbf9dfc14e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794343c5010fefe3ddfc1f319a79cf6b" id="r_a794343c5010fefe3ddfc1f319a79cf6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a794343c5010fefe3ddfc1f319a79cf6b">DOORBELL_OUT_SET</a></td></tr>
<tr class="memdesc:a794343c5010fefe3ddfc1f319a79cf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a doorbell interrupt on the opposite core.  <br /></td></tr>
<tr class="separator:a794343c5010fefe3ddfc1f319a79cf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8880cdac69030900938ee2a4ddb75b42" id="r_a8880cdac69030900938ee2a4ddb75b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a8880cdac69030900938ee2a4ddb75b42">FIFO_RD</a></td></tr>
<tr class="memdesc:a8880cdac69030900938ee2a4ddb75b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to this core's RX FIFO <br  />
  <br /></td></tr>
<tr class="separator:a8880cdac69030900938ee2a4ddb75b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69c29f781dbd283d2efa0c834f5b40e" id="r_aa69c29f781dbd283d2efa0c834f5b40e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa69c29f781dbd283d2efa0c834f5b40e">FIFO_ST</a></td></tr>
<tr class="memdesc:aa69c29f781dbd283d2efa0c834f5b40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register for inter-core FIFOs (mailboxes).  <br /></td></tr>
<tr class="separator:aa69c29f781dbd283d2efa0c834f5b40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3828b61a2c175b9cfb6b6b23fc6f9d27" id="r_a3828b61a2c175b9cfb6b6b23fc6f9d27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a3828b61a2c175b9cfb6b6b23fc6f9d27">FIFO_WR</a></td></tr>
<tr class="memdesc:a3828b61a2c175b9cfb6b6b23fc6f9d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write access to this core's TX FIFO <br  />
  <br /></td></tr>
<tr class="separator:a3828b61a2c175b9cfb6b6b23fc6f9d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98761f782f47a81ce48221eb44c4e2c5" id="r_a98761f782f47a81ce48221eb44c4e2c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a98761f782f47a81ce48221eb44c4e2c5">GPIO_HI_IN</a></td></tr>
<tr class="memdesc:a98761f782f47a81ce48221eb44c4e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input value for QSPI pins <br  />
  <br /></td></tr>
<tr class="separator:a98761f782f47a81ce48221eb44c4e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae11db6711e7656356d1b0686b50371f" id="r_aae11db6711e7656356d1b0686b50371f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aae11db6711e7656356d1b0686b50371f">GPIO_HI_OE</a></td></tr>
<tr class="memdesc:aae11db6711e7656356d1b0686b50371f"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI output enable <br  />
  <br /></td></tr>
<tr class="separator:aae11db6711e7656356d1b0686b50371f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b6fdc3e7bb716c4c7a6ed073ed5c0f" id="r_a86b6fdc3e7bb716c4c7a6ed073ed5c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a86b6fdc3e7bb716c4c7a6ed073ed5c0f">GPIO_HI_OE_CLR</a></td></tr>
<tr class="memdesc:a86b6fdc3e7bb716c4c7a6ed073ed5c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI output enable clear <br  />
  <br /></td></tr>
<tr class="separator:a86b6fdc3e7bb716c4c7a6ed073ed5c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0058b2dc446637de70d1fe377021b0" id="r_a5b0058b2dc446637de70d1fe377021b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a5b0058b2dc446637de70d1fe377021b0">GPIO_HI_OE_SET</a></td></tr>
<tr class="memdesc:a5b0058b2dc446637de70d1fe377021b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI output enable set <br  />
  <br /></td></tr>
<tr class="separator:a5b0058b2dc446637de70d1fe377021b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed186bfc593d23c39a982292972aa13c" id="r_aed186bfc593d23c39a982292972aa13c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aed186bfc593d23c39a982292972aa13c">GPIO_HI_OE_XOR</a></td></tr>
<tr class="memdesc:aed186bfc593d23c39a982292972aa13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI output enable XOR <br  />
  <br /></td></tr>
<tr class="separator:aed186bfc593d23c39a982292972aa13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1922b01e09fef3cc5efd24e0d30707" id="r_a5a1922b01e09fef3cc5efd24e0d30707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a5a1922b01e09fef3cc5efd24e0d30707">GPIO_HI_OUT</a></td></tr>
<tr class="memdesc:a5a1922b01e09fef3cc5efd24e0d30707"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI output value <br  />
  <br /></td></tr>
<tr class="separator:a5a1922b01e09fef3cc5efd24e0d30707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7db7278af9c9e4f15b19575775eec9f" id="r_ae7db7278af9c9e4f15b19575775eec9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ae7db7278af9c9e4f15b19575775eec9f">GPIO_HI_OUT_CLR</a></td></tr>
<tr class="memdesc:ae7db7278af9c9e4f15b19575775eec9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI output value clear <br  />
  <br /></td></tr>
<tr class="separator:ae7db7278af9c9e4f15b19575775eec9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974f811abe7897b7f6b24f4398074192" id="r_a974f811abe7897b7f6b24f4398074192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a974f811abe7897b7f6b24f4398074192">GPIO_HI_OUT_SET</a></td></tr>
<tr class="memdesc:a974f811abe7897b7f6b24f4398074192"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI output value set <br  />
  <br /></td></tr>
<tr class="separator:a974f811abe7897b7f6b24f4398074192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba475dcb2e2da96a91e23292a0aae9f" id="r_a8ba475dcb2e2da96a91e23292a0aae9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a8ba475dcb2e2da96a91e23292a0aae9f">GPIO_HI_OUT_XOR</a></td></tr>
<tr class="memdesc:a8ba475dcb2e2da96a91e23292a0aae9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI output value XOR <br  />
  <br /></td></tr>
<tr class="separator:a8ba475dcb2e2da96a91e23292a0aae9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf71ebb3e3aa5811a39af35934df927" id="r_acbf71ebb3e3aa5811a39af35934df927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#acbf71ebb3e3aa5811a39af35934df927">GPIO_IN</a></td></tr>
<tr class="memdesc:acbf71ebb3e3aa5811a39af35934df927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input value for GPIO pins <br  />
  <br /></td></tr>
<tr class="separator:acbf71ebb3e3aa5811a39af35934df927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd25beda5712faa213e2bedd067622e" id="r_accd25beda5712faa213e2bedd067622e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#accd25beda5712faa213e2bedd067622e">GPIO_OE</a></td></tr>
<tr class="memdesc:accd25beda5712faa213e2bedd067622e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO output enable <br  />
  <br /></td></tr>
<tr class="separator:accd25beda5712faa213e2bedd067622e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2098e369a8281645c7e9c589d94f89a" id="r_ab2098e369a8281645c7e9c589d94f89a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ab2098e369a8281645c7e9c589d94f89a">GPIO_OE_CLR</a></td></tr>
<tr class="memdesc:ab2098e369a8281645c7e9c589d94f89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO output enable clear <br  />
  <br /></td></tr>
<tr class="separator:ab2098e369a8281645c7e9c589d94f89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5516baae7345d571ac7058186d7d8df5" id="r_a5516baae7345d571ac7058186d7d8df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a5516baae7345d571ac7058186d7d8df5">GPIO_OE_SET</a></td></tr>
<tr class="memdesc:a5516baae7345d571ac7058186d7d8df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO output enable set <br  />
  <br /></td></tr>
<tr class="separator:a5516baae7345d571ac7058186d7d8df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639831f6da536b91687d38c9eda45a3e" id="r_a639831f6da536b91687d38c9eda45a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a639831f6da536b91687d38c9eda45a3e">GPIO_OE_XOR</a></td></tr>
<tr class="memdesc:a639831f6da536b91687d38c9eda45a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO output enable XOR <br  />
  <br /></td></tr>
<tr class="separator:a639831f6da536b91687d38c9eda45a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a7afc4fb1128414e231889a9c927b0" id="r_a62a7afc4fb1128414e231889a9c927b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a62a7afc4fb1128414e231889a9c927b0">GPIO_OUT</a></td></tr>
<tr class="memdesc:a62a7afc4fb1128414e231889a9c927b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO output value <br  />
  <br /></td></tr>
<tr class="separator:a62a7afc4fb1128414e231889a9c927b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa31dd4a88185c53f17669b2f208ad8" id="r_a0fa31dd4a88185c53f17669b2f208ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a0fa31dd4a88185c53f17669b2f208ad8">GPIO_OUT_CLR</a></td></tr>
<tr class="memdesc:a0fa31dd4a88185c53f17669b2f208ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO output value clear <br  />
  <br /></td></tr>
<tr class="separator:a0fa31dd4a88185c53f17669b2f208ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe9f50a23b6782f5d18e6eb215c1c1" id="r_a06fe9f50a23b6782f5d18e6eb215c1c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a06fe9f50a23b6782f5d18e6eb215c1c1">GPIO_OUT_SET</a></td></tr>
<tr class="memdesc:a06fe9f50a23b6782f5d18e6eb215c1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO output value set <br  />
  <br /></td></tr>
<tr class="separator:a06fe9f50a23b6782f5d18e6eb215c1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9911124cb106b544282f2399841910" id="r_a9e9911124cb106b544282f2399841910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a9e9911124cb106b544282f2399841910">GPIO_OUT_XOR</a></td></tr>
<tr class="memdesc:a9e9911124cb106b544282f2399841910"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO output value XOR <br  />
  <br /></td></tr>
<tr class="separator:a9e9911124cb106b544282f2399841910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019a16ce24cc83dac54335ee88c97842" id="r_a019a16ce24cc83dac54335ee88c97842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a019a16ce24cc83dac54335ee88c97842">INTERP0_ACCUM0</a></td></tr>
<tr class="memdesc:a019a16ce24cc83dac54335ee88c97842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to accumulator 0 <br  />
  <br /></td></tr>
<tr class="separator:a019a16ce24cc83dac54335ee88c97842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dd8d348460adf6f2d81cbcd6b95b07" id="r_a35dd8d348460adf6f2d81cbcd6b95b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a35dd8d348460adf6f2d81cbcd6b95b07">INTERP0_ACCUM0_ADD</a></td></tr>
<tr class="memdesc:a35dd8d348460adf6f2d81cbcd6b95b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added).  <br /></td></tr>
<tr class="separator:a35dd8d348460adf6f2d81cbcd6b95b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adade5e62e8c87b06b5bdbdb7e74105de" id="r_adade5e62e8c87b06b5bdbdb7e74105de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#adade5e62e8c87b06b5bdbdb7e74105de">INTERP0_ACCUM1</a></td></tr>
<tr class="memdesc:adade5e62e8c87b06b5bdbdb7e74105de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to accumulator 1 <br  />
  <br /></td></tr>
<tr class="separator:adade5e62e8c87b06b5bdbdb7e74105de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85810a8ad238920f58316f632b1556c" id="r_af85810a8ad238920f58316f632b1556c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#af85810a8ad238920f58316f632b1556c">INTERP0_ACCUM1_ADD</a></td></tr>
<tr class="memdesc:af85810a8ad238920f58316f632b1556c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added).  <br /></td></tr>
<tr class="separator:af85810a8ad238920f58316f632b1556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd26dc5f8968187dde3ca8eae9595d06" id="r_acd26dc5f8968187dde3ca8eae9595d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#acd26dc5f8968187dde3ca8eae9595d06">INTERP0_BASE0</a></td></tr>
<tr class="memdesc:acd26dc5f8968187dde3ca8eae9595d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to BASE0 register.  <br /></td></tr>
<tr class="separator:acd26dc5f8968187dde3ca8eae9595d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269b2ec1147d69605199a83551c2bb84" id="r_a269b2ec1147d69605199a83551c2bb84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a269b2ec1147d69605199a83551c2bb84">INTERP0_BASE1</a></td></tr>
<tr class="memdesc:a269b2ec1147d69605199a83551c2bb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to BASE1 register.  <br /></td></tr>
<tr class="separator:a269b2ec1147d69605199a83551c2bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be9c742f2a030d0a8a8489a6c6399e2" id="r_a3be9c742f2a030d0a8a8489a6c6399e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a3be9c742f2a030d0a8a8489a6c6399e2">INTERP0_BASE2</a></td></tr>
<tr class="memdesc:a3be9c742f2a030d0a8a8489a6c6399e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to BASE2 register.  <br /></td></tr>
<tr class="separator:a3be9c742f2a030d0a8a8489a6c6399e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f387ecf1859cd3862e0b6c67cb876aa" id="r_a2f387ecf1859cd3862e0b6c67cb876aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a2f387ecf1859cd3862e0b6c67cb876aa">INTERP0_BASE_1AND0</a></td></tr>
<tr class="memdesc:a2f387ecf1859cd3862e0b6c67cb876aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.  <br /></td></tr>
<tr class="separator:a2f387ecf1859cd3862e0b6c67cb876aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a73da9bee81f15a03e0cc4156a4d8b4" id="r_a2a73da9bee81f15a03e0cc4156a4d8b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a2a73da9bee81f15a03e0cc4156a4d8b4">INTERP0_CTRL_LANE0</a></td></tr>
<tr class="memdesc:a2a73da9bee81f15a03e0cc4156a4d8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register for lane 0 <br  />
  <br /></td></tr>
<tr class="separator:a2a73da9bee81f15a03e0cc4156a4d8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25d60fbc039a92ebd5de16119234a3c" id="r_ab25d60fbc039a92ebd5de16119234a3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ab25d60fbc039a92ebd5de16119234a3c">INTERP0_CTRL_LANE1</a></td></tr>
<tr class="memdesc:ab25d60fbc039a92ebd5de16119234a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register for lane 1 <br  />
  <br /></td></tr>
<tr class="separator:ab25d60fbc039a92ebd5de16119234a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dbd311550411084747642e8dfe485f" id="r_aa1dbd311550411084747642e8dfe485f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa1dbd311550411084747642e8dfe485f">INTERP0_PEEK_FULL</a></td></tr>
<tr class="memdesc:aa1dbd311550411084747642e8dfe485f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read FULL result, without altering any internal state (PEEK).  <br /></td></tr>
<tr class="separator:aa1dbd311550411084747642e8dfe485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b08933aa49b6e79a4597b7b23f50d7" id="r_a99b08933aa49b6e79a4597b7b23f50d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a99b08933aa49b6e79a4597b7b23f50d7">INTERP0_PEEK_LANE0</a></td></tr>
<tr class="memdesc:a99b08933aa49b6e79a4597b7b23f50d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LANE0 result, without altering any internal state (PEEK).  <br /></td></tr>
<tr class="separator:a99b08933aa49b6e79a4597b7b23f50d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25b0cf3b84013b15ff5df815a69ca3e" id="r_ad25b0cf3b84013b15ff5df815a69ca3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ad25b0cf3b84013b15ff5df815a69ca3e">INTERP0_PEEK_LANE1</a></td></tr>
<tr class="memdesc:ad25b0cf3b84013b15ff5df815a69ca3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LANE1 result, without altering any internal state (PEEK).  <br /></td></tr>
<tr class="separator:ad25b0cf3b84013b15ff5df815a69ca3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e3ecd86f0bda4b1282cbfcb974d66f" id="r_a93e3ecd86f0bda4b1282cbfcb974d66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a93e3ecd86f0bda4b1282cbfcb974d66f">INTERP0_POP_FULL</a></td></tr>
<tr class="memdesc:a93e3ecd86f0bda4b1282cbfcb974d66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read FULL result, and simultaneously write lane results to both accumulators (POP).  <br /></td></tr>
<tr class="separator:a93e3ecd86f0bda4b1282cbfcb974d66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdce600b627e887866e56edc6a279502" id="r_acdce600b627e887866e56edc6a279502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#acdce600b627e887866e56edc6a279502">INTERP0_POP_LANE0</a></td></tr>
<tr class="memdesc:acdce600b627e887866e56edc6a279502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LANE0 result, and simultaneously write lane results to both accumulators (POP).  <br /></td></tr>
<tr class="separator:acdce600b627e887866e56edc6a279502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c8ba2de0171c1fd7a840112fdb0cd7" id="r_a89c8ba2de0171c1fd7a840112fdb0cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a89c8ba2de0171c1fd7a840112fdb0cd7">INTERP0_POP_LANE1</a></td></tr>
<tr class="memdesc:a89c8ba2de0171c1fd7a840112fdb0cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LANE1 result, and simultaneously write lane results to both accumulators (POP).  <br /></td></tr>
<tr class="separator:a89c8ba2de0171c1fd7a840112fdb0cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bff2982c0fc1691194f59956f04383" id="r_a75bff2982c0fc1691194f59956f04383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a75bff2982c0fc1691194f59956f04383">INTERP1_ACCUM0</a></td></tr>
<tr class="memdesc:a75bff2982c0fc1691194f59956f04383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to accumulator 0 <br  />
  <br /></td></tr>
<tr class="separator:a75bff2982c0fc1691194f59956f04383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021d7b40eb196f1a0cf58dcb373b5c48" id="r_a021d7b40eb196f1a0cf58dcb373b5c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a021d7b40eb196f1a0cf58dcb373b5c48">INTERP1_ACCUM0_ADD</a></td></tr>
<tr class="memdesc:a021d7b40eb196f1a0cf58dcb373b5c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added).  <br /></td></tr>
<tr class="separator:a021d7b40eb196f1a0cf58dcb373b5c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493419589155d8410ef16b40591e563b" id="r_a493419589155d8410ef16b40591e563b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a493419589155d8410ef16b40591e563b">INTERP1_ACCUM1</a></td></tr>
<tr class="memdesc:a493419589155d8410ef16b40591e563b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to accumulator 1 <br  />
  <br /></td></tr>
<tr class="separator:a493419589155d8410ef16b40591e563b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98a1b76fb40dba84218189ebb094297" id="r_af98a1b76fb40dba84218189ebb094297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#af98a1b76fb40dba84218189ebb094297">INTERP1_ACCUM1_ADD</a></td></tr>
<tr class="memdesc:af98a1b76fb40dba84218189ebb094297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added).  <br /></td></tr>
<tr class="separator:af98a1b76fb40dba84218189ebb094297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d87eae5b2922da9f90cb2283730813" id="r_a11d87eae5b2922da9f90cb2283730813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a11d87eae5b2922da9f90cb2283730813">INTERP1_BASE0</a></td></tr>
<tr class="memdesc:a11d87eae5b2922da9f90cb2283730813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to BASE0 register.  <br /></td></tr>
<tr class="separator:a11d87eae5b2922da9f90cb2283730813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08e048bb82db2d480146e1b4e3ea282" id="r_aa08e048bb82db2d480146e1b4e3ea282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa08e048bb82db2d480146e1b4e3ea282">INTERP1_BASE1</a></td></tr>
<tr class="memdesc:aa08e048bb82db2d480146e1b4e3ea282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to BASE1 register.  <br /></td></tr>
<tr class="separator:aa08e048bb82db2d480146e1b4e3ea282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7188d73419fad4e3b553b05594b9be11" id="r_a7188d73419fad4e3b553b05594b9be11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a7188d73419fad4e3b553b05594b9be11">INTERP1_BASE2</a></td></tr>
<tr class="memdesc:a7188d73419fad4e3b553b05594b9be11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to BASE2 register.  <br /></td></tr>
<tr class="separator:a7188d73419fad4e3b553b05594b9be11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26dda28c28c9d36de3e264d17f798a0" id="r_aa26dda28c28c9d36de3e264d17f798a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa26dda28c28c9d36de3e264d17f798a0">INTERP1_BASE_1AND0</a></td></tr>
<tr class="memdesc:aa26dda28c28c9d36de3e264d17f798a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.  <br /></td></tr>
<tr class="separator:aa26dda28c28c9d36de3e264d17f798a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c1ec842327906b33393aa56794967a" id="r_aa5c1ec842327906b33393aa56794967a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa5c1ec842327906b33393aa56794967a">INTERP1_CTRL_LANE0</a></td></tr>
<tr class="memdesc:aa5c1ec842327906b33393aa56794967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register for lane 0 <br  />
  <br /></td></tr>
<tr class="separator:aa5c1ec842327906b33393aa56794967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa664cc634675c26a34a3f799be19bc8a" id="r_aa664cc634675c26a34a3f799be19bc8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa664cc634675c26a34a3f799be19bc8a">INTERP1_CTRL_LANE1</a></td></tr>
<tr class="memdesc:aa664cc634675c26a34a3f799be19bc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register for lane 1 <br  />
  <br /></td></tr>
<tr class="separator:aa664cc634675c26a34a3f799be19bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1377418cc12cd79bc5df416dcbdf835f" id="r_a1377418cc12cd79bc5df416dcbdf835f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a1377418cc12cd79bc5df416dcbdf835f">INTERP1_PEEK_FULL</a></td></tr>
<tr class="memdesc:a1377418cc12cd79bc5df416dcbdf835f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read FULL result, without altering any internal state (PEEK).  <br /></td></tr>
<tr class="separator:a1377418cc12cd79bc5df416dcbdf835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadea9c26a2142ce39828771e4c90d14e" id="r_aadea9c26a2142ce39828771e4c90d14e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aadea9c26a2142ce39828771e4c90d14e">INTERP1_PEEK_LANE0</a></td></tr>
<tr class="memdesc:aadea9c26a2142ce39828771e4c90d14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LANE0 result, without altering any internal state (PEEK).  <br /></td></tr>
<tr class="separator:aadea9c26a2142ce39828771e4c90d14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7834191170140bb18d9188a684e347f9" id="r_a7834191170140bb18d9188a684e347f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a7834191170140bb18d9188a684e347f9">INTERP1_PEEK_LANE1</a></td></tr>
<tr class="memdesc:a7834191170140bb18d9188a684e347f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LANE1 result, without altering any internal state (PEEK).  <br /></td></tr>
<tr class="separator:a7834191170140bb18d9188a684e347f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebbd481691ca3bcbbdee54c77e96272" id="r_a7ebbd481691ca3bcbbdee54c77e96272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a7ebbd481691ca3bcbbdee54c77e96272">INTERP1_POP_FULL</a></td></tr>
<tr class="memdesc:a7ebbd481691ca3bcbbdee54c77e96272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read FULL result, and simultaneously write lane results to both accumulators (POP).  <br /></td></tr>
<tr class="separator:a7ebbd481691ca3bcbbdee54c77e96272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23481ec65dd21e56fa566f58b26e983" id="r_ae23481ec65dd21e56fa566f58b26e983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ae23481ec65dd21e56fa566f58b26e983">INTERP1_POP_LANE0</a></td></tr>
<tr class="memdesc:ae23481ec65dd21e56fa566f58b26e983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LANE0 result, and simultaneously write lane results to both accumulators (POP).  <br /></td></tr>
<tr class="separator:ae23481ec65dd21e56fa566f58b26e983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a017614099472a2358a1d359f884ac5" id="r_a7a017614099472a2358a1d359f884ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a7a017614099472a2358a1d359f884ac5">INTERP1_POP_LANE1</a></td></tr>
<tr class="memdesc:a7a017614099472a2358a1d359f884ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LANE1 result, and simultaneously write lane results to both accumulators (POP).  <br /></td></tr>
<tr class="separator:a7a017614099472a2358a1d359f884ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bb2f7366d2cd82e3490664d6512253" id="r_a90bb2f7366d2cd82e3490664d6512253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a90bb2f7366d2cd82e3490664d6512253">MTIME</a></td></tr>
<tr class="memdesc:a90bb2f7366d2cd82e3490664d6512253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to the high half of RISC-V Machine-mode timer.  <br /></td></tr>
<tr class="separator:a90bb2f7366d2cd82e3490664d6512253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c17205e2ea8d396eeedfe216328276b" id="r_a1c17205e2ea8d396eeedfe216328276b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a1c17205e2ea8d396eeedfe216328276b">MTIME_CTRL</a></td></tr>
<tr class="memdesc:a1c17205e2ea8d396eeedfe216328276b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register for the RISC-V 64-bit Machine-mode timer.  <br /></td></tr>
<tr class="separator:a1c17205e2ea8d396eeedfe216328276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24ff2edd2dfabf7b7f8fd15e94def2e" id="r_ac24ff2edd2dfabf7b7f8fd15e94def2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ac24ff2edd2dfabf7b7f8fd15e94def2e">MTIMECMP</a></td></tr>
<tr class="memdesc:ac24ff2edd2dfabf7b7f8fd15e94def2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low half of RISC-V Machine-mode timer comparator.  <br /></td></tr>
<tr class="separator:ac24ff2edd2dfabf7b7f8fd15e94def2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cecdb179b422779e09fee39cc54661" id="r_a63cecdb179b422779e09fee39cc54661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a63cecdb179b422779e09fee39cc54661">MTIMECMPH</a></td></tr>
<tr class="memdesc:a63cecdb179b422779e09fee39cc54661"><td class="mdescLeft">&#160;</td><td class="mdescRight">High half of RISC-V Machine-mode timer comparator.  <br /></td></tr>
<tr class="separator:a63cecdb179b422779e09fee39cc54661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f10e5815e61d0cf19e77f34be5d007" id="r_aa2f10e5815e61d0cf19e77f34be5d007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa2f10e5815e61d0cf19e77f34be5d007">MTIMEH</a></td></tr>
<tr class="memdesc:aa2f10e5815e61d0cf19e77f34be5d007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to the high half of RISC-V Machine-mode timer.  <br /></td></tr>
<tr class="separator:aa2f10e5815e61d0cf19e77f34be5d007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc163f1f680f689e03c3d8dac9afcf4" id="r_a1fc163f1f680f689e03c3d8dac9afcf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a1fc163f1f680f689e03c3d8dac9afcf4">PERI_NONSEC</a></td></tr>
<tr class="memdesc:a1fc163f1f680f689e03c3d8dac9afcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach certain core-local peripherals from Secure SIO, and attach them to Non-secure SIO, so that Non-secure software can use them.  <br /></td></tr>
<tr class="separator:a1fc163f1f680f689e03c3d8dac9afcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee766f43def9de374d3fc47ecbaa30" id="r_a5aee766f43def9de374d3fc47ecbaa30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#ga4cc1649793116d7c2d8afce7a4ffce43">__IM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a5aee766f43def9de374d3fc47ecbaa30">RESERVED</a></td></tr>
<tr class="separator:a5aee766f43def9de374d3fc47ecbaa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c9a82b6cbdd263adaadef7ba2fbd83" id="r_ab6c9a82b6cbdd263adaadef7ba2fbd83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#ga4cc1649793116d7c2d8afce7a4ffce43">__IM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ab6c9a82b6cbdd263adaadef7ba2fbd83">RESERVED1</a></td></tr>
<tr class="separator:ab6c9a82b6cbdd263adaadef7ba2fbd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5ca36869b958a4ae115a22e395ec46" id="r_a2d5ca36869b958a4ae115a22e395ec46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#ga4cc1649793116d7c2d8afce7a4ffce43">__IM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a2d5ca36869b958a4ae115a22e395ec46">RESERVED2</a> [3]</td></tr>
<tr class="separator:a2d5ca36869b958a4ae115a22e395ec46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94046ef087c168ecd19a08c9a27b5b36" id="r_a94046ef087c168ecd19a08c9a27b5b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#ga4cc1649793116d7c2d8afce7a4ffce43">__IM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a94046ef087c168ecd19a08c9a27b5b36">RESERVED3</a> [2]</td></tr>
<tr class="separator:a94046ef087c168ecd19a08c9a27b5b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7ea9b7f838529135bab98569a79151" id="r_a3d7ea9b7f838529135bab98569a79151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a3d7ea9b7f838529135bab98569a79151">RISCV_SOFTIRQ</a></td></tr>
<tr class="memdesc:a3d7ea9b7f838529135bab98569a79151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the assertion of the standard software interrupt (MIP.MSIP) on the RISC-V cores.  <br /></td></tr>
<tr class="separator:a3d7ea9b7f838529135bab98569a79151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9797860305c537dd33c1034ea1b301fd" id="r_a9797860305c537dd33c1034ea1b301fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a9797860305c537dd33c1034ea1b301fd">SPINLOCK0</a></td></tr>
<tr class="memdesc:a9797860305c537dd33c1034ea1b301fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a9797860305c537dd33c1034ea1b301fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e6f25e50f2bacd9db65e0c44f08ce4" id="r_a65e6f25e50f2bacd9db65e0c44f08ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a65e6f25e50f2bacd9db65e0c44f08ce4">SPINLOCK1</a></td></tr>
<tr class="memdesc:a65e6f25e50f2bacd9db65e0c44f08ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a65e6f25e50f2bacd9db65e0c44f08ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e324a151bc21dc7e5b2312cc45d851a" id="r_a8e324a151bc21dc7e5b2312cc45d851a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a8e324a151bc21dc7e5b2312cc45d851a">SPINLOCK10</a></td></tr>
<tr class="memdesc:a8e324a151bc21dc7e5b2312cc45d851a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a8e324a151bc21dc7e5b2312cc45d851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7cb91f46af6120e0691aa8228debf2" id="r_a6b7cb91f46af6120e0691aa8228debf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a6b7cb91f46af6120e0691aa8228debf2">SPINLOCK11</a></td></tr>
<tr class="memdesc:a6b7cb91f46af6120e0691aa8228debf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a6b7cb91f46af6120e0691aa8228debf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f52f93a97a80a8413fa31cea4e087d3" id="r_a4f52f93a97a80a8413fa31cea4e087d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a4f52f93a97a80a8413fa31cea4e087d3">SPINLOCK12</a></td></tr>
<tr class="memdesc:a4f52f93a97a80a8413fa31cea4e087d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a4f52f93a97a80a8413fa31cea4e087d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b701da13a65c1b7cd119e21bcb86b6d" id="r_a2b701da13a65c1b7cd119e21bcb86b6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a2b701da13a65c1b7cd119e21bcb86b6d">SPINLOCK13</a></td></tr>
<tr class="memdesc:a2b701da13a65c1b7cd119e21bcb86b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a2b701da13a65c1b7cd119e21bcb86b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dfc401e72e2d860479d6be6b84f1e5" id="r_ac3dfc401e72e2d860479d6be6b84f1e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ac3dfc401e72e2d860479d6be6b84f1e5">SPINLOCK14</a></td></tr>
<tr class="memdesc:ac3dfc401e72e2d860479d6be6b84f1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:ac3dfc401e72e2d860479d6be6b84f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0540899a5eb7ea7c67eaf78826be8d4" id="r_ac0540899a5eb7ea7c67eaf78826be8d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ac0540899a5eb7ea7c67eaf78826be8d4">SPINLOCK15</a></td></tr>
<tr class="memdesc:ac0540899a5eb7ea7c67eaf78826be8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:ac0540899a5eb7ea7c67eaf78826be8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0614ad4c20459127bde999b002bbc77" id="r_aa0614ad4c20459127bde999b002bbc77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa0614ad4c20459127bde999b002bbc77">SPINLOCK16</a></td></tr>
<tr class="memdesc:aa0614ad4c20459127bde999b002bbc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:aa0614ad4c20459127bde999b002bbc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55e205120aa7300b37c44a10b5bfbd2" id="r_ad55e205120aa7300b37c44a10b5bfbd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ad55e205120aa7300b37c44a10b5bfbd2">SPINLOCK17</a></td></tr>
<tr class="memdesc:ad55e205120aa7300b37c44a10b5bfbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:ad55e205120aa7300b37c44a10b5bfbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c993c7b7552efcc57d04d31e426f7d" id="r_a37c993c7b7552efcc57d04d31e426f7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a37c993c7b7552efcc57d04d31e426f7d">SPINLOCK18</a></td></tr>
<tr class="memdesc:a37c993c7b7552efcc57d04d31e426f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a37c993c7b7552efcc57d04d31e426f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ea4c8cd5a5b4627bf82206be0934a1" id="r_a65ea4c8cd5a5b4627bf82206be0934a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a65ea4c8cd5a5b4627bf82206be0934a1">SPINLOCK19</a></td></tr>
<tr class="memdesc:a65ea4c8cd5a5b4627bf82206be0934a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a65ea4c8cd5a5b4627bf82206be0934a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1259db634dfd2df126b8269e1f9031b" id="r_ae1259db634dfd2df126b8269e1f9031b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ae1259db634dfd2df126b8269e1f9031b">SPINLOCK2</a></td></tr>
<tr class="memdesc:ae1259db634dfd2df126b8269e1f9031b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:ae1259db634dfd2df126b8269e1f9031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06df134b960f9f0b6636c06dc97b3f" id="r_a3d06df134b960f9f0b6636c06dc97b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a3d06df134b960f9f0b6636c06dc97b3f">SPINLOCK20</a></td></tr>
<tr class="memdesc:a3d06df134b960f9f0b6636c06dc97b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a3d06df134b960f9f0b6636c06dc97b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4e01cd483410892edf4781c422460e" id="r_a7a4e01cd483410892edf4781c422460e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a7a4e01cd483410892edf4781c422460e">SPINLOCK21</a></td></tr>
<tr class="memdesc:a7a4e01cd483410892edf4781c422460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a7a4e01cd483410892edf4781c422460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31189df0445fc2366a6c68f63ccae8bd" id="r_a31189df0445fc2366a6c68f63ccae8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a31189df0445fc2366a6c68f63ccae8bd">SPINLOCK22</a></td></tr>
<tr class="memdesc:a31189df0445fc2366a6c68f63ccae8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a31189df0445fc2366a6c68f63ccae8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e478d402615c2f1fd872fbe060ead43" id="r_a7e478d402615c2f1fd872fbe060ead43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a7e478d402615c2f1fd872fbe060ead43">SPINLOCK23</a></td></tr>
<tr class="memdesc:a7e478d402615c2f1fd872fbe060ead43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a7e478d402615c2f1fd872fbe060ead43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4153ef4b61796cef525731deb6ddfbe" id="r_ad4153ef4b61796cef525731deb6ddfbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ad4153ef4b61796cef525731deb6ddfbe">SPINLOCK24</a></td></tr>
<tr class="memdesc:ad4153ef4b61796cef525731deb6ddfbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:ad4153ef4b61796cef525731deb6ddfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57ad63a4abc6468e35b49c34b059f2c" id="r_ae57ad63a4abc6468e35b49c34b059f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ae57ad63a4abc6468e35b49c34b059f2c">SPINLOCK25</a></td></tr>
<tr class="memdesc:ae57ad63a4abc6468e35b49c34b059f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:ae57ad63a4abc6468e35b49c34b059f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e674e3ebf778f3db099287940d52c23" id="r_a8e674e3ebf778f3db099287940d52c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a8e674e3ebf778f3db099287940d52c23">SPINLOCK26</a></td></tr>
<tr class="memdesc:a8e674e3ebf778f3db099287940d52c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a8e674e3ebf778f3db099287940d52c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2976e0d10b55bfe38112cc231161dc" id="r_acd2976e0d10b55bfe38112cc231161dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#acd2976e0d10b55bfe38112cc231161dc">SPINLOCK27</a></td></tr>
<tr class="memdesc:acd2976e0d10b55bfe38112cc231161dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:acd2976e0d10b55bfe38112cc231161dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883b0766e4eced880eb974ba61f7df73" id="r_a883b0766e4eced880eb974ba61f7df73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a883b0766e4eced880eb974ba61f7df73">SPINLOCK28</a></td></tr>
<tr class="memdesc:a883b0766e4eced880eb974ba61f7df73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a883b0766e4eced880eb974ba61f7df73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918bc518a7a23de15cc755192a9ad7bd" id="r_a918bc518a7a23de15cc755192a9ad7bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a918bc518a7a23de15cc755192a9ad7bd">SPINLOCK29</a></td></tr>
<tr class="memdesc:a918bc518a7a23de15cc755192a9ad7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a918bc518a7a23de15cc755192a9ad7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9add6d64841e3d851d20c513a81c435c" id="r_a9add6d64841e3d851d20c513a81c435c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a9add6d64841e3d851d20c513a81c435c">SPINLOCK3</a></td></tr>
<tr class="memdesc:a9add6d64841e3d851d20c513a81c435c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a9add6d64841e3d851d20c513a81c435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7927a690e9d50727d0074f748f3d31" id="r_a6c7927a690e9d50727d0074f748f3d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a6c7927a690e9d50727d0074f748f3d31">SPINLOCK30</a></td></tr>
<tr class="memdesc:a6c7927a690e9d50727d0074f748f3d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a6c7927a690e9d50727d0074f748f3d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afde5aaaa4097337b65fbf82774a981" id="r_a4afde5aaaa4097337b65fbf82774a981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a4afde5aaaa4097337b65fbf82774a981">SPINLOCK31</a></td></tr>
<tr class="memdesc:a4afde5aaaa4097337b65fbf82774a981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a4afde5aaaa4097337b65fbf82774a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caff0582865883d43d01799e706e0c3" id="r_a1caff0582865883d43d01799e706e0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a1caff0582865883d43d01799e706e0c3">SPINLOCK4</a></td></tr>
<tr class="memdesc:a1caff0582865883d43d01799e706e0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a1caff0582865883d43d01799e706e0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c430395f3765f9c628b21f0bc2ad2f" id="r_ad5c430395f3765f9c628b21f0bc2ad2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#ad5c430395f3765f9c628b21f0bc2ad2f">SPINLOCK5</a></td></tr>
<tr class="memdesc:ad5c430395f3765f9c628b21f0bc2ad2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:ad5c430395f3765f9c628b21f0bc2ad2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8484348ae1eba0159825e22474716e" id="r_a1d8484348ae1eba0159825e22474716e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a1d8484348ae1eba0159825e22474716e">SPINLOCK6</a></td></tr>
<tr class="memdesc:a1d8484348ae1eba0159825e22474716e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a1d8484348ae1eba0159825e22474716e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829f7ccefa09550e4c342df89d6673e8" id="r_a829f7ccefa09550e4c342df89d6673e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a829f7ccefa09550e4c342df89d6673e8">SPINLOCK7</a></td></tr>
<tr class="memdesc:a829f7ccefa09550e4c342df89d6673e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a829f7ccefa09550e4c342df89d6673e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e42aa4e84b3efb98307959597f73f6" id="r_a05e42aa4e84b3efb98307959597f73f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a05e42aa4e84b3efb98307959597f73f6">SPINLOCK8</a></td></tr>
<tr class="memdesc:a05e42aa4e84b3efb98307959597f73f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a05e42aa4e84b3efb98307959597f73f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197a31dd3949c6eabc154073a544fae1" id="r_a197a31dd3949c6eabc154073a544fae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a197a31dd3949c6eabc154073a544fae1">SPINLOCK9</a></td></tr>
<tr class="memdesc:a197a31dd3949c6eabc154073a544fae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock.  <br /></td></tr>
<tr class="separator:a197a31dd3949c6eabc154073a544fae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21de8ceb8c04b8be590a5dc09212042a" id="r_a21de8ceb8c04b8be590a5dc09212042a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a21de8ceb8c04b8be590a5dc09212042a">SPINLOCK_ST</a></td></tr>
<tr class="memdesc:a21de8ceb8c04b8be590a5dc09212042a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinlock state A bitmap containing the state of all 32 spinlocks (1=locked).  <br /></td></tr>
<tr class="separator:a21de8ceb8c04b8be590a5dc09212042a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c85b6f13a3e497e5ceb9de6e8e9d6b" id="r_a74c85b6f13a3e497e5ceb9de6e8e9d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a74c85b6f13a3e497e5ceb9de6e8e9d6b">TMDS_CTRL</a></td></tr>
<tr class="memdesc:a74c85b6f13a3e497e5ceb9de6e8e9d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register for TMDS encoder.  <br /></td></tr>
<tr class="separator:a74c85b6f13a3e497e5ceb9de6e8e9d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb18302a30883d809392fc953d1e614b" id="r_acb18302a30883d809392fc953d1e614b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#acb18302a30883d809392fc953d1e614b">TMDS_PEEK_DOUBLE_L0</a></td></tr>
<tr class="memdesc:acb18302a30883d809392fc953d1e614b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lane 0 of the encoding of two pixels' worth of colour data.  <br /></td></tr>
<tr class="separator:acb18302a30883d809392fc953d1e614b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921411e119881a58262e317f6ffed4ec" id="r_a921411e119881a58262e317f6ffed4ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a921411e119881a58262e317f6ffed4ec">TMDS_PEEK_DOUBLE_L1</a></td></tr>
<tr class="memdesc:a921411e119881a58262e317f6ffed4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lane 1 of the encoding of two pixels' worth of colour data.  <br /></td></tr>
<tr class="separator:a921411e119881a58262e317f6ffed4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81be93f0d8a89932ac313e2893051c6f" id="r_a81be93f0d8a89932ac313e2893051c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a81be93f0d8a89932ac313e2893051c6f">TMDS_PEEK_DOUBLE_L2</a></td></tr>
<tr class="memdesc:a81be93f0d8a89932ac313e2893051c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lane 2 of the encoding of two pixels' worth of colour data.  <br /></td></tr>
<tr class="separator:a81be93f0d8a89932ac313e2893051c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24183ed65b63411c28d464a3b6b4798" id="r_aa24183ed65b63411c28d464a3b6b4798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aa24183ed65b63411c28d464a3b6b4798">TMDS_PEEK_SINGLE</a></td></tr>
<tr class="memdesc:aa24183ed65b63411c28d464a3b6b4798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoding of one pixel's worth of colour data, packed into a 32-bit value (3x10-bit symbols).  <br /></td></tr>
<tr class="separator:aa24183ed65b63411c28d464a3b6b4798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf82028406b24fb6f9a9ee8c0b919196" id="r_aaf82028406b24fb6f9a9ee8c0b919196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#aaf82028406b24fb6f9a9ee8c0b919196">TMDS_POP_DOUBLE_L0</a></td></tr>
<tr class="memdesc:aaf82028406b24fb6f9a9ee8c0b919196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lane 0 of the encoding of two pixels' worth of colour data.  <br /></td></tr>
<tr class="separator:aaf82028406b24fb6f9a9ee8c0b919196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b12b1686c05f7f74d227454a95c3d90" id="r_a9b12b1686c05f7f74d227454a95c3d90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a9b12b1686c05f7f74d227454a95c3d90">TMDS_POP_DOUBLE_L1</a></td></tr>
<tr class="memdesc:a9b12b1686c05f7f74d227454a95c3d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lane 1 of the encoding of two pixels' worth of colour data.  <br /></td></tr>
<tr class="separator:a9b12b1686c05f7f74d227454a95c3d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6139330afe4b375b057963a35d8dbfd9" id="r_a6139330afe4b375b057963a35d8dbfd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a6139330afe4b375b057963a35d8dbfd9">TMDS_POP_DOUBLE_L2</a></td></tr>
<tr class="memdesc:a6139330afe4b375b057963a35d8dbfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lane 2 of the encoding of two pixels' worth of colour data.  <br /></td></tr>
<tr class="separator:a6139330afe4b375b057963a35d8dbfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c574436ea0a7362b4ad4b27ac6d94a3" id="r_a2c574436ea0a7362b4ad4b27ac6d94a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a2c574436ea0a7362b4ad4b27ac6d94a3">TMDS_POP_SINGLE</a></td></tr>
<tr class="memdesc:a2c574436ea0a7362b4ad4b27ac6d94a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoding of one pixel's worth of colour data, packed into a 32-bit value.  <br /></td></tr>
<tr class="separator:a2c574436ea0a7362b4ad4b27ac6d94a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21015755e0ceaacdb43818ba93485268" id="r_a21015755e0ceaacdb43818ba93485268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSIO__Type.html#a21015755e0ceaacdb43818ba93485268">TMDS_WDATA</a></td></tr>
<tr class="memdesc:a21015755e0ceaacdb43818ba93485268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-only access to the TMDS colour data register.  <br /></td></tr>
<tr class="separator:a21015755e0ceaacdb43818ba93485268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrição detalhada</h2>
<div class="textblock"><p>Single-cycle IO block Provides core-local and inter-core hardware for the two processors, with single-cycle access. </p>
<p>(SIO) </p>
</div><h2 class="groupheader">Documentação dos dados membro</h2>
<a id="aeb692e1c4217d833569f3bc5eda2baac" name="aeb692e1c4217d833569f3bc5eda2baac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb692e1c4217d833569f3bc5eda2baac">&#9670;&#160;</a></span>CPUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::CPUID</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; SIO Structure <br  />
 </p>
<p>Processor core identifier <br  />
 </p>

</div>
</div>
<a id="a55046d567803ba2a3f571b221fc738cb" name="a55046d567803ba2a3f571b221fc738cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55046d567803ba2a3f571b221fc738cb">&#9670;&#160;</a></span>DIV_CSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DIV_CSR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control and status register for divider. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a3048037c445d1ede7cda6a7853e65a11" name="a3048037c445d1ede7cda6a7853e65a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3048037c445d1ede7cda6a7853e65a11">&#9670;&#160;</a></span>DIV_QUOTIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DIV_QUOTIENT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divider result quotient The result of <code>DIVIDEND / DIVISOR</code> (division). </p>
<p>Contents undefined while CSR_READY is low. For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and DIVISOR differ. This register can be written to directly, for context save/restore purposes. This halts any in-progress calculation and sets the CSR_READY and CSR_DIRTY flags. Reading from QUOTIENT clears the CSR_DIRTY flag, so should read results in the order REMAINDER, QUOTIENT if CSR_DIRTY is used. <br  />
 </p>

</div>
</div>
<a id="ab3cc705f5b2432a89e9b5ae741512a39" name="ab3cc705f5b2432a89e9b5ae741512a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cc705f5b2432a89e9b5ae741512a39">&#9670;&#160;</a></span>DIV_REMAINDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DIV_REMAINDER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divider result remainder The result of <code>DIVIDEND % DIVISOR</code> (modulo). </p>
<p>Contents undefined while CSR_READY is low. For signed calculations, REMAINDER is negative only when DIVIDEND is negative. This register can be written to directly, for context save/restore purposes. This halts any in-progress calculation and sets the CSR_READY and CSR_DIRTY flags. <br  />
 </p>

</div>
</div>
<a id="abf296c5f7af423160435fab596f140f0" name="abf296c5f7af423160435fab596f140f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf296c5f7af423160435fab596f140f0">&#9670;&#160;</a></span>DIV_SDIVIDEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DIV_SDIVIDEND</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divider signed dividend The same as UDIVIDEND, but starts a signed calculation, rather than unsigned. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a09b20cde79d38f5d1c9370e729a8ef45" name="a09b20cde79d38f5d1c9370e729a8ef45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b20cde79d38f5d1c9370e729a8ef45">&#9670;&#160;</a></span>DIV_SDIVISOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DIV_SDIVISOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divider signed divisor The same as UDIVISOR, but starts a signed calculation, rather than unsigned. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a18b2b6921c68180bf82179d2a51a53be" name="a18b2b6921c68180bf82179d2a51a53be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b2b6921c68180bf82179d2a51a53be">&#9670;&#160;</a></span>DIV_UDIVIDEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DIV_UDIVIDEND</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divider unsigned dividend Write to the DIVIDEND operand of the divider, i.e. </p>
<p>the p in <code>p / q</code>. Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an unsigned calculation, and the S alias starts a signed calculation. <br  />
 </p>

</div>
</div>
<a id="a5b5260b2673871962f43552e0bf08b5d" name="a5b5260b2673871962f43552e0bf08b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5260b2673871962f43552e0bf08b5d">&#9670;&#160;</a></span>DIV_UDIVISOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DIV_UDIVISOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divider unsigned divisor Write to the DIVISOR operand of the divider, i.e. </p>
<p>the q in <code>p / q</code>. Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. UDIVISOR/SDIVISOR are aliases of the same internal register. The U alias starts an unsigned calculation, and the S alias starts a signed calculation. <br  />
 </p>

</div>
</div>
<a id="a028cb8c35b7250e8a09c8fbcb62cfe49" name="a028cb8c35b7250e8a09c8fbcb62cfe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028cb8c35b7250e8a09c8fbcb62cfe49">&#9670;&#160;</a></span>DOORBELL_IN_CLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DOORBELL_IN_CLR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check and acknowledge doorbells posted to this core. </p>
<p>This core's doorbell interrupt is asserted when any bit in this register is 1. Write 1 to each bit to clear that bit. The doorbell interrupt deasserts once all bits are cleared. Read to get status of doorbells currently asserted on this core. <br  />
 </p>

</div>
</div>
<a id="a74dae0e5457c91c3ffdd054c9a44cc17" name="a74dae0e5457c91c3ffdd054c9a44cc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74dae0e5457c91c3ffdd054c9a44cc17">&#9670;&#160;</a></span>DOORBELL_IN_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DOORBELL_IN_SET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 1s to trigger doorbell interrupts on this core. </p>
<p>Read to get status of doorbells currently asserted on this core. <br  />
 </p>

</div>
</div>
<a id="ab89ff7dc9692ffb340b68bbf9dfc14e8" name="ab89ff7dc9692ffb340b68bbf9dfc14e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89ff7dc9692ffb340b68bbf9dfc14e8">&#9670;&#160;</a></span>DOORBELL_OUT_CLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DOORBELL_OUT_CLR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear doorbells which have been posted to the opposite core. </p>
<p>This register is intended for debugging and initialisation purposes. Writing 1 to a bit in DOORBELL_OUT_CLR clears the corresponding bit in DOORBELL_IN on the opposite core. Clearing all bits will cause that core's doorbell interrupt to deassert. Since the usual order of events is for software to send events using DOORBELL_OUT_SET, and acknowledge incoming events by writing to DOORBELL_IN_CLR, this register should be used with caution to avoid race conditions. Reading returns the status of the doorbells currently asserted on the other core, i.e. is equivalent to that core reading its own DOORBELL_IN status. <br  />
 </p>

</div>
</div>
<a id="a794343c5010fefe3ddfc1f319a79cf6b" name="a794343c5010fefe3ddfc1f319a79cf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794343c5010fefe3ddfc1f319a79cf6b">&#9670;&#160;</a></span>DOORBELL_OUT_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::DOORBELL_OUT_SET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a doorbell interrupt on the opposite core. </p>
<p>Write 1 to a bit to set the corresponding bit in DOORBELL_IN on the opposite core. This raises the opposite core's doorbell interrupt. Read to get the status of the doorbells currently asserted on the opposite core. This is equivalent to that core reading its own DOORBELL_IN status. <br  />
 </p>

</div>
</div>
<a id="a8880cdac69030900938ee2a4ddb75b42" name="a8880cdac69030900938ee2a4ddb75b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8880cdac69030900938ee2a4ddb75b42">&#9670;&#160;</a></span>FIFO_RD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::FIFO_RD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read access to this core's RX FIFO <br  />
 </p>

</div>
</div>
<a id="aa69c29f781dbd283d2efa0c834f5b40e" name="aa69c29f781dbd283d2efa0c834f5b40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69c29f781dbd283d2efa0c834f5b40e">&#9670;&#160;</a></span>FIFO_ST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::FIFO_ST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status register for inter-core FIFOs (mailboxes). </p>
<p>There is one FIFO in the core 0 -&gt; core 1 direction, and one core 1 -&gt; core 0. Both are 32 bits wide and 8 words deep. Core 0 can see the read side of the 1-&gt;0 FIFO (RX), and the write side of 0-&gt;1 FIFO (TX). Core 1 can see the read side of the 0-&gt;1 FIFO (RX), and the write side of 1-&gt;0 FIFO (TX). The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register. <br  />
 </p>

</div>
</div>
<a id="a3828b61a2c175b9cfb6b6b23fc6f9d27" name="a3828b61a2c175b9cfb6b6b23fc6f9d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3828b61a2c175b9cfb6b6b23fc6f9d27">&#9670;&#160;</a></span>FIFO_WR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::FIFO_WR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write access to this core's TX FIFO <br  />
 </p>

</div>
</div>
<a id="a98761f782f47a81ce48221eb44c4e2c5" name="a98761f782f47a81ce48221eb44c4e2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98761f782f47a81ce48221eb44c4e2c5">&#9670;&#160;</a></span>GPIO_HI_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_IN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input value for QSPI pins <br  />
 </p>
<p>Input value on GPIO32...47, QSPI IOs and USB pins In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero.</p>
<p><br  />
 </p>

</div>
</div>
<a id="aae11db6711e7656356d1b0686b50371f" name="aae11db6711e7656356d1b0686b50371f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae11db6711e7656356d1b0686b50371f">&#9670;&#160;</a></span>GPIO_HI_OE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_OE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI output enable <br  />
 </p>
<p>Output enable value for GPIO32...47, QSPI IOs and USB pins.</p>
<p>Write output enable (1/0 -&gt; output/input). Reading back gives the last value written. If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result. In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register. <br  />
 </p>

</div>
</div>
<a id="a86b6fdc3e7bb716c4c7a6ed073ed5c0f" name="a86b6fdc3e7bb716c4c7a6ed073ed5c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b6fdc3e7bb716c4c7a6ed073ed5c0f">&#9670;&#160;</a></span>GPIO_HI_OE_CLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_OE_CLR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI output enable clear <br  />
 </p>
<p>Output enable clear for GPIO32...47, QSPI IOs and USB pins.</p>
<p>Perform an atomic bit-clear on GPIO_HI_OE, i.e. <code>GPIO_HI_OE &amp;= ~wdata</code> <br  />
 </p>

</div>
</div>
<a id="a5b0058b2dc446637de70d1fe377021b0" name="a5b0058b2dc446637de70d1fe377021b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0058b2dc446637de70d1fe377021b0">&#9670;&#160;</a></span>GPIO_HI_OE_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_OE_SET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI output enable set <br  />
 </p>
<p>Output enable set for GPIO32...47, QSPI IOs and USB pins.</p>
<p>Perform an atomic bit-set on GPIO_HI_OE, i.e. <code>GPIO_HI_OE |= wdata</code> <br  />
 </p>

</div>
</div>
<a id="aed186bfc593d23c39a982292972aa13c" name="aed186bfc593d23c39a982292972aa13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed186bfc593d23c39a982292972aa13c">&#9670;&#160;</a></span>GPIO_HI_OE_XOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_OE_XOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI output enable XOR <br  />
 </p>
<p>Output enable XOR for GPIO32...47, QSPI IOs and USB pins.</p>
<p>Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. <code>GPIO_HI_OE ^= wdata</code> <br  />
 </p>

</div>
</div>
<a id="a5a1922b01e09fef3cc5efd24e0d30707" name="a5a1922b01e09fef3cc5efd24e0d30707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1922b01e09fef3cc5efd24e0d30707">&#9670;&#160;</a></span>GPIO_HI_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_OUT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI output value <br  />
 </p>
<p>Output value for GPIO32...47, QSPI IOs and USB pins.</p>
<p>Write to set output level (1/0 -&gt; high/low). Reading back gives the last value written, NOT the input value from the pins. If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result. In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register. <br  />
 </p>

</div>
</div>
<a id="ae7db7278af9c9e4f15b19575775eec9f" name="ae7db7278af9c9e4f15b19575775eec9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7db7278af9c9e4f15b19575775eec9f">&#9670;&#160;</a></span>GPIO_HI_OUT_CLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_OUT_CLR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI output value clear <br  />
 </p>
<p>Output value clear for GPIO32..47, QSPI IOs and USB pins.</p>
<p>Perform an atomic bit-clear on GPIO_HI_OUT, i.e. <code>GPIO_HI_OUT &amp;= ~wdata</code> <br  />
 </p>

</div>
</div>
<a id="a974f811abe7897b7f6b24f4398074192" name="a974f811abe7897b7f6b24f4398074192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974f811abe7897b7f6b24f4398074192">&#9670;&#160;</a></span>GPIO_HI_OUT_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_OUT_SET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI output value set <br  />
 </p>
<p>Output value set for GPIO32..47, QSPI IOs and USB pins.</p>
<p>Perform an atomic bit-set on GPIO_HI_OUT, i.e. <code>GPIO_HI_OUT |= wdata</code> <br  />
 </p>

</div>
</div>
<a id="a8ba475dcb2e2da96a91e23292a0aae9f" name="a8ba475dcb2e2da96a91e23292a0aae9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba475dcb2e2da96a91e23292a0aae9f">&#9670;&#160;</a></span>GPIO_HI_OUT_XOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_HI_OUT_XOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI output value XOR <br  />
 </p>
<p>Output value XOR for GPIO32..47, QSPI IOs and USB pins.</p>
<p>Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. <code>GPIO_HI_OUT ^= wdata</code> <br  />
 </p>

</div>
</div>
<a id="acbf71ebb3e3aa5811a39af35934df927" name="acbf71ebb3e3aa5811a39af35934df927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf71ebb3e3aa5811a39af35934df927">&#9670;&#160;</a></span>GPIO_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_IN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input value for GPIO pins <br  />
 </p>
<p>Input value for GPIO0...31.</p>
<p>In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero. <br  />
 </p>

</div>
</div>
<a id="accd25beda5712faa213e2bedd067622e" name="accd25beda5712faa213e2bedd067622e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd25beda5712faa213e2bedd067622e">&#9670;&#160;</a></span>GPIO_OE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_OE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO output enable <br  />
 </p>
<p>GPIO0...31 output enable <br  />
 </p>

</div>
</div>
<a id="ab2098e369a8281645c7e9c589d94f89a" name="ab2098e369a8281645c7e9c589d94f89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2098e369a8281645c7e9c589d94f89a">&#9670;&#160;</a></span>GPIO_OE_CLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_OE_CLR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO output enable clear <br  />
 </p>
<p>GPIO0...31 output enable clear <br  />
 </p>

</div>
</div>
<a id="a5516baae7345d571ac7058186d7d8df5" name="a5516baae7345d571ac7058186d7d8df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5516baae7345d571ac7058186d7d8df5">&#9670;&#160;</a></span>GPIO_OE_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_OE_SET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO output enable set <br  />
 </p>
<p>GPIO0...31 output enable set <br  />
 </p>

</div>
</div>
<a id="a639831f6da536b91687d38c9eda45a3e" name="a639831f6da536b91687d38c9eda45a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639831f6da536b91687d38c9eda45a3e">&#9670;&#160;</a></span>GPIO_OE_XOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_OE_XOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO output enable XOR <br  />
 </p>
<p>GPIO0...31 output enable XOR <br  />
 </p>

</div>
</div>
<a id="a62a7afc4fb1128414e231889a9c927b0" name="a62a7afc4fb1128414e231889a9c927b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a7afc4fb1128414e231889a9c927b0">&#9670;&#160;</a></span>GPIO_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_OUT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO output value <br  />
 </p>
<p>GPIO0...31 output value <br  />
 </p>

</div>
</div>
<a id="a0fa31dd4a88185c53f17669b2f208ad8" name="a0fa31dd4a88185c53f17669b2f208ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa31dd4a88185c53f17669b2f208ad8">&#9670;&#160;</a></span>GPIO_OUT_CLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_OUT_CLR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO output value clear <br  />
 </p>
<p>GPIO0...31 output value clear <br  />
 </p>

</div>
</div>
<a id="a06fe9f50a23b6782f5d18e6eb215c1c1" name="a06fe9f50a23b6782f5d18e6eb215c1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fe9f50a23b6782f5d18e6eb215c1c1">&#9670;&#160;</a></span>GPIO_OUT_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_OUT_SET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO output value set <br  />
 </p>
<p>GPIO0...31 output value set <br  />
 </p>

</div>
</div>
<a id="a9e9911124cb106b544282f2399841910" name="a9e9911124cb106b544282f2399841910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9911124cb106b544282f2399841910">&#9670;&#160;</a></span>GPIO_OUT_XOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::GPIO_OUT_XOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO output value XOR <br  />
 </p>
<p>GPIO0...31 output value XOR <br  />
 </p>

</div>
</div>
<a id="a019a16ce24cc83dac54335ee88c97842" name="a019a16ce24cc83dac54335ee88c97842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019a16ce24cc83dac54335ee88c97842">&#9670;&#160;</a></span>INTERP0_ACCUM0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_ACCUM0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to accumulator 0 <br  />
 </p>

</div>
</div>
<a id="a35dd8d348460adf6f2d81cbcd6b95b07" name="a35dd8d348460adf6f2d81cbcd6b95b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dd8d348460adf6f2d81cbcd6b95b07">&#9670;&#160;</a></span>INTERP0_ACCUM0_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_ACCUM0_ADD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added). </p>
<p><br  />
 </p>

</div>
</div>
<a id="adade5e62e8c87b06b5bdbdb7e74105de" name="adade5e62e8c87b06b5bdbdb7e74105de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adade5e62e8c87b06b5bdbdb7e74105de">&#9670;&#160;</a></span>INTERP0_ACCUM1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_ACCUM1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to accumulator 1 <br  />
 </p>

</div>
</div>
<a id="af85810a8ad238920f58316f632b1556c" name="af85810a8ad238920f58316f632b1556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85810a8ad238920f58316f632b1556c">&#9670;&#160;</a></span>INTERP0_ACCUM1_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_ACCUM1_ADD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added). </p>
<p><br  />
 </p>

</div>
</div>
<a id="acd26dc5f8968187dde3ca8eae9595d06" name="acd26dc5f8968187dde3ca8eae9595d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd26dc5f8968187dde3ca8eae9595d06">&#9670;&#160;</a></span>INTERP0_BASE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_BASE0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to BASE0 register. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a269b2ec1147d69605199a83551c2bb84" name="a269b2ec1147d69605199a83551c2bb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269b2ec1147d69605199a83551c2bb84">&#9670;&#160;</a></span>INTERP0_BASE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_BASE1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to BASE1 register. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a3be9c742f2a030d0a8a8489a6c6399e2" name="a3be9c742f2a030d0a8a8489a6c6399e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be9c742f2a030d0a8a8489a6c6399e2">&#9670;&#160;</a></span>INTERP0_BASE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_BASE2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to BASE2 register. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a2f387ecf1859cd3862e0b6c67cb876aa" name="a2f387ecf1859cd3862e0b6c67cb876aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f387ecf1859cd3862e0b6c67cb876aa">&#9670;&#160;</a></span>INTERP0_BASE_1AND0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_BASE_1AND0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. </p>
<p>Each half is sign-extended to 32 bits if that lane's SIGNED flag is set. <br  />
 </p>

</div>
</div>
<a id="a2a73da9bee81f15a03e0cc4156a4d8b4" name="a2a73da9bee81f15a03e0cc4156a4d8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a73da9bee81f15a03e0cc4156a4d8b4">&#9670;&#160;</a></span>INTERP0_CTRL_LANE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_CTRL_LANE0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control register for lane 0 <br  />
 </p>

</div>
</div>
<a id="ab25d60fbc039a92ebd5de16119234a3c" name="ab25d60fbc039a92ebd5de16119234a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25d60fbc039a92ebd5de16119234a3c">&#9670;&#160;</a></span>INTERP0_CTRL_LANE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_CTRL_LANE1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control register for lane 1 <br  />
 </p>

</div>
</div>
<a id="aa1dbd311550411084747642e8dfe485f" name="aa1dbd311550411084747642e8dfe485f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dbd311550411084747642e8dfe485f">&#9670;&#160;</a></span>INTERP0_PEEK_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_PEEK_FULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read FULL result, without altering any internal state (PEEK). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a99b08933aa49b6e79a4597b7b23f50d7" name="a99b08933aa49b6e79a4597b7b23f50d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b08933aa49b6e79a4597b7b23f50d7">&#9670;&#160;</a></span>INTERP0_PEEK_LANE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_PEEK_LANE0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LANE0 result, without altering any internal state (PEEK). </p>
<p><br  />
 </p>

</div>
</div>
<a id="ad25b0cf3b84013b15ff5df815a69ca3e" name="ad25b0cf3b84013b15ff5df815a69ca3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25b0cf3b84013b15ff5df815a69ca3e">&#9670;&#160;</a></span>INTERP0_PEEK_LANE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_PEEK_LANE1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LANE1 result, without altering any internal state (PEEK). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a93e3ecd86f0bda4b1282cbfcb974d66f" name="a93e3ecd86f0bda4b1282cbfcb974d66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e3ecd86f0bda4b1282cbfcb974d66f">&#9670;&#160;</a></span>INTERP0_POP_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_POP_FULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read FULL result, and simultaneously write lane results to both accumulators (POP). </p>
<p><br  />
 </p>

</div>
</div>
<a id="acdce600b627e887866e56edc6a279502" name="acdce600b627e887866e56edc6a279502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdce600b627e887866e56edc6a279502">&#9670;&#160;</a></span>INTERP0_POP_LANE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_POP_LANE0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LANE0 result, and simultaneously write lane results to both accumulators (POP). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a89c8ba2de0171c1fd7a840112fdb0cd7" name="a89c8ba2de0171c1fd7a840112fdb0cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c8ba2de0171c1fd7a840112fdb0cd7">&#9670;&#160;</a></span>INTERP0_POP_LANE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP0_POP_LANE1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LANE1 result, and simultaneously write lane results to both accumulators (POP). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a75bff2982c0fc1691194f59956f04383" name="a75bff2982c0fc1691194f59956f04383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bff2982c0fc1691194f59956f04383">&#9670;&#160;</a></span>INTERP1_ACCUM0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_ACCUM0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to accumulator 0 <br  />
 </p>

</div>
</div>
<a id="a021d7b40eb196f1a0cf58dcb373b5c48" name="a021d7b40eb196f1a0cf58dcb373b5c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021d7b40eb196f1a0cf58dcb373b5c48">&#9670;&#160;</a></span>INTERP1_ACCUM0_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_ACCUM0_ADD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a493419589155d8410ef16b40591e563b" name="a493419589155d8410ef16b40591e563b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493419589155d8410ef16b40591e563b">&#9670;&#160;</a></span>INTERP1_ACCUM1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_ACCUM1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to accumulator 1 <br  />
 </p>

</div>
</div>
<a id="af98a1b76fb40dba84218189ebb094297" name="af98a1b76fb40dba84218189ebb094297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98a1b76fb40dba84218189ebb094297">&#9670;&#160;</a></span>INTERP1_ACCUM1_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_ACCUM1_ADD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a11d87eae5b2922da9f90cb2283730813" name="a11d87eae5b2922da9f90cb2283730813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d87eae5b2922da9f90cb2283730813">&#9670;&#160;</a></span>INTERP1_BASE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_BASE0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to BASE0 register. </p>
<p><br  />
 </p>

</div>
</div>
<a id="aa08e048bb82db2d480146e1b4e3ea282" name="aa08e048bb82db2d480146e1b4e3ea282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08e048bb82db2d480146e1b4e3ea282">&#9670;&#160;</a></span>INTERP1_BASE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_BASE1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to BASE1 register. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a7188d73419fad4e3b553b05594b9be11" name="a7188d73419fad4e3b553b05594b9be11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7188d73419fad4e3b553b05594b9be11">&#9670;&#160;</a></span>INTERP1_BASE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_BASE2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to BASE2 register. </p>
<p><br  />
 </p>

</div>
</div>
<a id="aa26dda28c28c9d36de3e264d17f798a0" name="aa26dda28c28c9d36de3e264d17f798a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26dda28c28c9d36de3e264d17f798a0">&#9670;&#160;</a></span>INTERP1_BASE_1AND0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_BASE_1AND0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. </p>
<p>Each half is sign-extended to 32 bits if that lane's SIGNED flag is set. <br  />
 </p>

</div>
</div>
<a id="aa5c1ec842327906b33393aa56794967a" name="aa5c1ec842327906b33393aa56794967a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c1ec842327906b33393aa56794967a">&#9670;&#160;</a></span>INTERP1_CTRL_LANE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_CTRL_LANE0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control register for lane 0 <br  />
 </p>

</div>
</div>
<a id="aa664cc634675c26a34a3f799be19bc8a" name="aa664cc634675c26a34a3f799be19bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa664cc634675c26a34a3f799be19bc8a">&#9670;&#160;</a></span>INTERP1_CTRL_LANE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_CTRL_LANE1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control register for lane 1 <br  />
 </p>

</div>
</div>
<a id="a1377418cc12cd79bc5df416dcbdf835f" name="a1377418cc12cd79bc5df416dcbdf835f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1377418cc12cd79bc5df416dcbdf835f">&#9670;&#160;</a></span>INTERP1_PEEK_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_PEEK_FULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read FULL result, without altering any internal state (PEEK). </p>
<p><br  />
 </p>

</div>
</div>
<a id="aadea9c26a2142ce39828771e4c90d14e" name="aadea9c26a2142ce39828771e4c90d14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadea9c26a2142ce39828771e4c90d14e">&#9670;&#160;</a></span>INTERP1_PEEK_LANE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_PEEK_LANE0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LANE0 result, without altering any internal state (PEEK). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a7834191170140bb18d9188a684e347f9" name="a7834191170140bb18d9188a684e347f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7834191170140bb18d9188a684e347f9">&#9670;&#160;</a></span>INTERP1_PEEK_LANE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_PEEK_LANE1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LANE1 result, without altering any internal state (PEEK). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a7ebbd481691ca3bcbbdee54c77e96272" name="a7ebbd481691ca3bcbbdee54c77e96272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebbd481691ca3bcbbdee54c77e96272">&#9670;&#160;</a></span>INTERP1_POP_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_POP_FULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read FULL result, and simultaneously write lane results to both accumulators (POP). </p>
<p><br  />
 </p>

</div>
</div>
<a id="ae23481ec65dd21e56fa566f58b26e983" name="ae23481ec65dd21e56fa566f58b26e983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23481ec65dd21e56fa566f58b26e983">&#9670;&#160;</a></span>INTERP1_POP_LANE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_POP_LANE0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LANE0 result, and simultaneously write lane results to both accumulators (POP). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a7a017614099472a2358a1d359f884ac5" name="a7a017614099472a2358a1d359f884ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a017614099472a2358a1d359f884ac5">&#9670;&#160;</a></span>INTERP1_POP_LANE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::INTERP1_POP_LANE1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LANE1 result, and simultaneously write lane results to both accumulators (POP). </p>
<p><br  />
 </p>

</div>
</div>
<a id="a90bb2f7366d2cd82e3490664d6512253" name="a90bb2f7366d2cd82e3490664d6512253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bb2f7366d2cd82e3490664d6512253">&#9670;&#160;</a></span>MTIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::MTIME</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to the high half of RISC-V Machine-mode timer. </p>
<p>This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence. <br  />
 </p>

</div>
</div>
<a id="a1c17205e2ea8d396eeedfe216328276b" name="a1c17205e2ea8d396eeedfe216328276b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c17205e2ea8d396eeedfe216328276b">&#9670;&#160;</a></span>MTIME_CTRL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::MTIME_CTRL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control register for the RISC-V 64-bit Machine-mode timer. </p>
<p>This timer is only present in the Secure SIO, so is only accessible to an Arm core in Secure mode or a RISC-V core in Machine mode. Note whilst this timer follows the RISC-V privileged specification, it is equally usable by the Arm cores. The interrupts are routed to normal system-level interrupt lines as well as to the MIP.MTIP inputs on the RISC-V cores. <br  />
 </p>

</div>
</div>
<a id="ac24ff2edd2dfabf7b7f8fd15e94def2e" name="ac24ff2edd2dfabf7b7f8fd15e94def2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24ff2edd2dfabf7b7f8fd15e94def2e">&#9670;&#160;</a></span>MTIMECMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::MTIMECMP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low half of RISC-V Machine-mode timer comparator. </p>
<p>This register is core-local, i.e., each core gets a copy of this register, with the comparison result routed to its own interrupt line. The timer interrupt is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and performed on the full 64-bit values. <br  />
 </p>

</div>
</div>
<a id="a63cecdb179b422779e09fee39cc54661" name="a63cecdb179b422779e09fee39cc54661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cecdb179b422779e09fee39cc54661">&#9670;&#160;</a></span>MTIMECMPH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::MTIMECMPH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High half of RISC-V Machine-mode timer comparator. </p>
<p>This register is core-local. The timer interrupt is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and performed on the full 64-bit values. <br  />
 </p>

</div>
</div>
<a id="aa2f10e5815e61d0cf19e77f34be5d007" name="aa2f10e5815e61d0cf19e77f34be5d007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f10e5815e61d0cf19e77f34be5d007">&#9670;&#160;</a></span>MTIMEH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::MTIMEH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write access to the high half of RISC-V Machine-mode timer. </p>
<p>This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence. <br  />
 </p>

</div>
</div>
<a id="a1fc163f1f680f689e03c3d8dac9afcf4" name="a1fc163f1f680f689e03c3d8dac9afcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc163f1f680f689e03c3d8dac9afcf4">&#9670;&#160;</a></span>PERI_NONSEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::PERI_NONSEC</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach certain core-local peripherals from Secure SIO, and attach them to Non-secure SIO, so that Non-secure software can use them. </p>
<p>Attempting to access one of these peripherals from the Secure SIO when it is attached to the Non-secure SIO, or vice versa, will generate a bus error. This register is per-core, and is only present on the Secure SIO. Most SIO hardware is duplicated across the Secure and Non-secure SIO, so is not listed in this register. <br  />
 </p>

</div>
</div>
<a id="a5aee766f43def9de374d3fc47ecbaa30" name="a5aee766f43def9de374d3fc47ecbaa30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aee766f43def9de374d3fc47ecbaa30">&#9670;&#160;</a></span>RESERVED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#ga4cc1649793116d7c2d8afce7a4ffce43">__IM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::RESERVED</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6c9a82b6cbdd263adaadef7ba2fbd83" name="ab6c9a82b6cbdd263adaadef7ba2fbd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c9a82b6cbdd263adaadef7ba2fbd83">&#9670;&#160;</a></span>RESERVED1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#ga4cc1649793116d7c2d8afce7a4ffce43">__IM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::RESERVED1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d5ca36869b958a4ae115a22e395ec46" name="a2d5ca36869b958a4ae115a22e395ec46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5ca36869b958a4ae115a22e395ec46">&#9670;&#160;</a></span>RESERVED2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#ga4cc1649793116d7c2d8afce7a4ffce43">__IM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::RESERVED2[3]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94046ef087c168ecd19a08c9a27b5b36" name="a94046ef087c168ecd19a08c9a27b5b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94046ef087c168ecd19a08c9a27b5b36">&#9670;&#160;</a></span>RESERVED3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#ga4cc1649793116d7c2d8afce7a4ffce43">__IM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::RESERVED3[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d7ea9b7f838529135bab98569a79151" name="a3d7ea9b7f838529135bab98569a79151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7ea9b7f838529135bab98569a79151">&#9670;&#160;</a></span>RISCV_SOFTIRQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::RISCV_SOFTIRQ</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the assertion of the standard software interrupt (MIP.MSIP) on the RISC-V cores. </p>
<p>Unlike the RISC-V timer, this interrupt is not routed to a normal system-level interrupt line, so can not be used by the Arm cores. It is safe for both cores to write to this register on the same cycle. The set/clear effect is accumulated across both cores, and then applied. If a flag is both set and cleared on the same cycle, only the set takes effect. <br  />
 </p>

</div>
</div>
<a id="a9797860305c537dd33c1034ea1b301fd" name="a9797860305c537dd33c1034ea1b301fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9797860305c537dd33c1034ea1b301fd">&#9670;&#160;</a></span>SPINLOCK0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a65e6f25e50f2bacd9db65e0c44f08ce4" name="a65e6f25e50f2bacd9db65e0c44f08ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e6f25e50f2bacd9db65e0c44f08ce4">&#9670;&#160;</a></span>SPINLOCK1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a8e324a151bc21dc7e5b2312cc45d851a" name="a8e324a151bc21dc7e5b2312cc45d851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e324a151bc21dc7e5b2312cc45d851a">&#9670;&#160;</a></span>SPINLOCK10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a6b7cb91f46af6120e0691aa8228debf2" name="a6b7cb91f46af6120e0691aa8228debf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7cb91f46af6120e0691aa8228debf2">&#9670;&#160;</a></span>SPINLOCK11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a4f52f93a97a80a8413fa31cea4e087d3" name="a4f52f93a97a80a8413fa31cea4e087d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f52f93a97a80a8413fa31cea4e087d3">&#9670;&#160;</a></span>SPINLOCK12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a2b701da13a65c1b7cd119e21bcb86b6d" name="a2b701da13a65c1b7cd119e21bcb86b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b701da13a65c1b7cd119e21bcb86b6d">&#9670;&#160;</a></span>SPINLOCK13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK13</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="ac3dfc401e72e2d860479d6be6b84f1e5" name="ac3dfc401e72e2d860479d6be6b84f1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dfc401e72e2d860479d6be6b84f1e5">&#9670;&#160;</a></span>SPINLOCK14</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="ac0540899a5eb7ea7c67eaf78826be8d4" name="ac0540899a5eb7ea7c67eaf78826be8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0540899a5eb7ea7c67eaf78826be8d4">&#9670;&#160;</a></span>SPINLOCK15</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="aa0614ad4c20459127bde999b002bbc77" name="aa0614ad4c20459127bde999b002bbc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0614ad4c20459127bde999b002bbc77">&#9670;&#160;</a></span>SPINLOCK16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="ad55e205120aa7300b37c44a10b5bfbd2" name="ad55e205120aa7300b37c44a10b5bfbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55e205120aa7300b37c44a10b5bfbd2">&#9670;&#160;</a></span>SPINLOCK17</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK17</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a37c993c7b7552efcc57d04d31e426f7d" name="a37c993c7b7552efcc57d04d31e426f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c993c7b7552efcc57d04d31e426f7d">&#9670;&#160;</a></span>SPINLOCK18</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK18</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a65ea4c8cd5a5b4627bf82206be0934a1" name="a65ea4c8cd5a5b4627bf82206be0934a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ea4c8cd5a5b4627bf82206be0934a1">&#9670;&#160;</a></span>SPINLOCK19</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK19</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="ae1259db634dfd2df126b8269e1f9031b" name="ae1259db634dfd2df126b8269e1f9031b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1259db634dfd2df126b8269e1f9031b">&#9670;&#160;</a></span>SPINLOCK2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a3d06df134b960f9f0b6636c06dc97b3f" name="a3d06df134b960f9f0b6636c06dc97b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d06df134b960f9f0b6636c06dc97b3f">&#9670;&#160;</a></span>SPINLOCK20</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a7a4e01cd483410892edf4781c422460e" name="a7a4e01cd483410892edf4781c422460e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4e01cd483410892edf4781c422460e">&#9670;&#160;</a></span>SPINLOCK21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK21</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a31189df0445fc2366a6c68f63ccae8bd" name="a31189df0445fc2366a6c68f63ccae8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31189df0445fc2366a6c68f63ccae8bd">&#9670;&#160;</a></span>SPINLOCK22</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK22</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a7e478d402615c2f1fd872fbe060ead43" name="a7e478d402615c2f1fd872fbe060ead43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e478d402615c2f1fd872fbe060ead43">&#9670;&#160;</a></span>SPINLOCK23</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK23</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="ad4153ef4b61796cef525731deb6ddfbe" name="ad4153ef4b61796cef525731deb6ddfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4153ef4b61796cef525731deb6ddfbe">&#9670;&#160;</a></span>SPINLOCK24</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK24</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="ae57ad63a4abc6468e35b49c34b059f2c" name="ae57ad63a4abc6468e35b49c34b059f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57ad63a4abc6468e35b49c34b059f2c">&#9670;&#160;</a></span>SPINLOCK25</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK25</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a8e674e3ebf778f3db099287940d52c23" name="a8e674e3ebf778f3db099287940d52c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e674e3ebf778f3db099287940d52c23">&#9670;&#160;</a></span>SPINLOCK26</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK26</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="acd2976e0d10b55bfe38112cc231161dc" name="acd2976e0d10b55bfe38112cc231161dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2976e0d10b55bfe38112cc231161dc">&#9670;&#160;</a></span>SPINLOCK27</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK27</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a883b0766e4eced880eb974ba61f7df73" name="a883b0766e4eced880eb974ba61f7df73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883b0766e4eced880eb974ba61f7df73">&#9670;&#160;</a></span>SPINLOCK28</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK28</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a918bc518a7a23de15cc755192a9ad7bd" name="a918bc518a7a23de15cc755192a9ad7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918bc518a7a23de15cc755192a9ad7bd">&#9670;&#160;</a></span>SPINLOCK29</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK29</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a9add6d64841e3d851d20c513a81c435c" name="a9add6d64841e3d851d20c513a81c435c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9add6d64841e3d851d20c513a81c435c">&#9670;&#160;</a></span>SPINLOCK3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a6c7927a690e9d50727d0074f748f3d31" name="a6c7927a690e9d50727d0074f748f3d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7927a690e9d50727d0074f748f3d31">&#9670;&#160;</a></span>SPINLOCK30</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK30</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a4afde5aaaa4097337b65fbf82774a981" name="a4afde5aaaa4097337b65fbf82774a981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afde5aaaa4097337b65fbf82774a981">&#9670;&#160;</a></span>SPINLOCK31</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK31</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a1caff0582865883d43d01799e706e0c3" name="a1caff0582865883d43d01799e706e0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1caff0582865883d43d01799e706e0c3">&#9670;&#160;</a></span>SPINLOCK4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="ad5c430395f3765f9c628b21f0bc2ad2f" name="ad5c430395f3765f9c628b21f0bc2ad2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c430395f3765f9c628b21f0bc2ad2f">&#9670;&#160;</a></span>SPINLOCK5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a1d8484348ae1eba0159825e22474716e" name="a1d8484348ae1eba0159825e22474716e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8484348ae1eba0159825e22474716e">&#9670;&#160;</a></span>SPINLOCK6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a829f7ccefa09550e4c342df89d6673e8" name="a829f7ccefa09550e4c342df89d6673e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829f7ccefa09550e4c342df89d6673e8">&#9670;&#160;</a></span>SPINLOCK7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a05e42aa4e84b3efb98307959597f73f6" name="a05e42aa4e84b3efb98307959597f73f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e42aa4e84b3efb98307959597f73f6">&#9670;&#160;</a></span>SPINLOCK8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a197a31dd3949c6eabc154073a544fae1" name="a197a31dd3949c6eabc154073a544fae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197a31dd3949c6eabc154073a544fae1">&#9670;&#160;</a></span>SPINLOCK9</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. </p>
<p>If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 &lt;&lt; lock number. <br  />
 </p>

</div>
</div>
<a id="a21de8ceb8c04b8be590a5dc09212042a" name="a21de8ceb8c04b8be590a5dc09212042a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21de8ceb8c04b8be590a5dc09212042a">&#9670;&#160;</a></span>SPINLOCK_ST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::SPINLOCK_ST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spinlock state A bitmap containing the state of all 32 spinlocks (1=locked). </p>
<p>Mainly intended for debugging. <br  />
 </p>

</div>
</div>
<a id="a74c85b6f13a3e497e5ceb9de6e8e9d6b" name="a74c85b6f13a3e497e5ceb9de6e8e9d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c85b6f13a3e497e5ceb9de6e8e9d6b">&#9670;&#160;</a></span>TMDS_CTRL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_CTRL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control register for TMDS encoder. </p>
<p><br  />
 </p>

</div>
</div>
<a id="acb18302a30883d809392fc953d1e614b" name="acb18302a30883d809392fc953d1e614b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb18302a30883d809392fc953d1e614b">&#9670;&#160;</a></span>TMDS_PEEK_DOUBLE_L0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_PEEK_DOUBLE_L0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lane 0 of the encoding of two pixels' worth of colour data. </p>
<p>Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The PEEK alias does not shift the colour register when read, but still advances the lane 0 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane. <br  />
 </p>

</div>
</div>
<a id="a921411e119881a58262e317f6ffed4ec" name="a921411e119881a58262e317f6ffed4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921411e119881a58262e317f6ffed4ec">&#9670;&#160;</a></span>TMDS_PEEK_DOUBLE_L1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_PEEK_DOUBLE_L1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lane 1 of the encoding of two pixels' worth of colour data. </p>
<p>Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The PEEK alias does not shift the colour register when read, but still advances the lane 1 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane. <br  />
 </p>

</div>
</div>
<a id="a81be93f0d8a89932ac313e2893051c6f" name="a81be93f0d8a89932ac313e2893051c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81be93f0d8a89932ac313e2893051c6f">&#9670;&#160;</a></span>TMDS_PEEK_DOUBLE_L2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_PEEK_DOUBLE_L2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lane 2 of the encoding of two pixels' worth of colour data. </p>
<p>Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The PEEK alias does not shift the colour register when read, but still advances the lane 2 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane. <br  />
 </p>

</div>
</div>
<a id="aa24183ed65b63411c28d464a3b6b4798" name="aa24183ed65b63411c28d464a3b6b4798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24183ed65b63411c28d464a3b6b4798">&#9670;&#160;</a></span>TMDS_PEEK_SINGLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_PEEK_SINGLE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the encoding of one pixel's worth of colour data, packed into a 32-bit value (3x10-bit symbols). </p>
<p>The PEEK alias does not shift the colour register when read, but still advances the running DC balance state of each encoder. This is useful for pixel doubling. <br  />
 </p>

</div>
</div>
<a id="aaf82028406b24fb6f9a9ee8c0b919196" name="aaf82028406b24fb6f9a9ee8c0b919196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf82028406b24fb6f9a9ee8c0b919196">&#9670;&#160;</a></span>TMDS_POP_DOUBLE_L0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_POP_DOUBLE_L0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lane 0 of the encoding of two pixels' worth of colour data. </p>
<p>Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT. <br  />
 </p>

</div>
</div>
<a id="a9b12b1686c05f7f74d227454a95c3d90" name="a9b12b1686c05f7f74d227454a95c3d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b12b1686c05f7f74d227454a95c3d90">&#9670;&#160;</a></span>TMDS_POP_DOUBLE_L1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_POP_DOUBLE_L1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lane 1 of the encoding of two pixels' worth of colour data. </p>
<p>Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT. <br  />
 </p>

</div>
</div>
<a id="a6139330afe4b375b057963a35d8dbfd9" name="a6139330afe4b375b057963a35d8dbfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6139330afe4b375b057963a35d8dbfd9">&#9670;&#160;</a></span>TMDS_POP_DOUBLE_L2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_POP_DOUBLE_L2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lane 2 of the encoding of two pixels' worth of colour data. </p>
<p>Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT. <br  />
 </p>

</div>
</div>
<a id="a2c574436ea0a7362b4ad4b27ac6d94a3" name="a2c574436ea0a7362b4ad4b27ac6d94a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c574436ea0a7362b4ad4b27ac6d94a3">&#9670;&#160;</a></span>TMDS_POP_SINGLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_POP_SINGLE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the encoding of one pixel's worth of colour data, packed into a 32-bit value. </p>
<p>The packing is 5 chunks of 3 lanes times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per lane. This format is intended for shifting out with the HSTX peripheral on RP2350. The POP alias shifts the colour register when read, as well as advancing the running DC balance state of each encoder. <br  />
 </p>

</div>
</div>
<a id="a21015755e0ceaacdb43818ba93485268" name="a21015755e0ceaacdb43818ba93485268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21015755e0ceaacdb43818ba93485268">&#9670;&#160;</a></span>TMDS_WDATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RP2350.html#gab6caba5853a60a17e8e04499b52bf691">__IOM</a> <a class="el" href="bootrom_8h.html#aeb4191163d43ca89913bb54da45cbbc8">uint32_t</a> SIO_Type::TMDS_WDATA</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write-only access to the TMDS colour data register. </p>
<p><br  />
 </p>

</div>
</div>
<hr/>A documentação para esta estrutura foi gerada a partir dos seguintes ficheiros:<ul>
<li><a class="el" href="RP2040_8h_source.html">RP2040.h</a></li>
<li><a class="el" href="RP2350_8h_source.html">RP2350.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structSIO__Type.html">SIO_Type</a></li>
    <li class="footer">Gerado por <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
